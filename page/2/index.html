<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yhcs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/14/C-%E5%AE%B9%E5%99%A8%E5%92%8C%E7%B1%BB%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/14/C-%E5%AE%B9%E5%99%A8%E5%92%8C%E7%B1%BB%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">C++:容器和类容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-14 15:58:21 / 修改时间：16:00:58" itemprop="dateCreated datePublished" datetime="2024-08-14T15:58:21+08:00">2024-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="容器和类容器"><a href="#容器和类容器" class="headerlink" title="容器和类容器"></a>容器和类容器</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>1.<code>string</code>不是容器，但是有跟序列容器类似的成员函数</p>
<ul>
<li><code>begin</code>和<code>end</code></li>
<li><code>empty</code></li>
<li><code>size</code></li>
<li><code>swap</code>（支持交换）</li>
<li>支持<code>==、&lt;</code>等比较运算</li>
</ul>
<p>2.<code>string</code>的内存布局</p>
<table>
<thead>
<tr>
<th>h</th>
<th>e</th>
<th>l</th>
<th>l</th>
<th>o</th>
<th>!</th>
<th>\0</th>
</tr>
</thead>
<tbody><tr>
<td><code>begin</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>end</code></td>
</tr>
<tr>
<td><code>front</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>back</code></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>begin</code>和<code>end</code>是迭代器，类似于指针，<code>end</code>指向末尾+1</li>
<li><code>front</code>和<code>back</code>是引用</li>
</ul>
<p>3.<code>string</code>其他用法</p>
<ul>
<li><code>size()</code>的复杂度是O(1)，<code>strlen()</code>的复杂度是O(N)</li>
<li>支持字符串的拼接和查找</li>
<li><code>nops</code>是一个string的常数，当查找不存在的字符时会返回 <code>nops</code></li>
<li>支持到数字的互转： <code>stoi()</code>和 <code>to_string</code></li>
</ul>
<h3 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h4><p><code>array</code>的特点：</p>
<ol>
<li><p>和C数组一样在栈上分配，性能方面没有差异</p>
</li>
<li><p>需要编译期确定数组大小</p>
</li>
<li><p>提供了 <code>begin</code>、 <code>end</code>、 <code>size</code>等通用成员函数</p>
</li>
<li><p>解决了C数组的怪异行为</p>
<ul>
<li><p>不能按值拷贝，具体表现：</p>
<p>a. 直接赋值：在C中，不能直接将一个数组赋值给另一个数组，<code>int a[5] = &#123;1, 2, 3, 4, 5&#125;; int b[5]; b = a;</code>是非法的，<code>array&lt;int, 5&gt; a = &#123;1, 2, 3, 4, 5&#125;; array&lt;int, 5&gt; b; b = a;</code>是合法的</p>
<p>b. 函数传参：数组作为函数参数，实际上传递的是指向数组的指针，而不是整个数组的拷贝</p>
</li>
<li><p>作为参数有退化行为，被调用函数不能获得C数组的长度</p>
</li>
</ul>
</li>
<li><p>支持 <code>==</code> <code>&lt;</code>等比较运算（原生数组不能直接使用比较运算符，此时比较的是两个数组的地址，<code>array</code>、<code>vector</code>会自动逐元素比较数组）</p>
</li>
</ol>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a><code>vector</code></h4><ul>
<li>最常用的序列容器</li>
<li>大小可变的动态数组</li>
<li>为尾部增删元素而优化</li>
</ul>
<p><strong>vector的内存布局</strong></p>
<p><img src="/../assets/C-%E5%AE%B9%E5%99%A8%E5%92%8C%E7%B1%BB%E5%AE%B9%E5%99%A8/image-20240814142205726.png" alt="image-20240814142205726"></p>
<ul>
<li>begin、end：指针、迭代器</li>
<li>front、back：引用</li>
</ul>
<p><strong>异常安全要求</strong></p>
<p>当 <code>vector</code> 空间不够时，扩容时希望在内存重分配时使用元素的移动构造函数的话，必须声明为 <code>noexcept</code></p>
<p>否则容器会使用拷贝构造函数</p>
<p>原因：保证强异常安全性，在 <code>vector</code>的 <code>insert、push_back</code>等操作中保证强异常安全性，怎么实现：如果插入的时候空间不够会扩容，在新的内存块中相应的位置构造要求插入的成员，如果失败的话，抛异常并释放内存，如果成功的话，将原先的内存拷贝或者移动过去。如果在移动过程中出现异常，新的内存块没构造完成，旧的内存块被移走，就没办法保证强安全性。 <code>vector</code>保证强异常安全性是指：如果操作失败，能够保证完整的回退到当前插入操作之前的状态。</p>
<p>示例程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj1</span>(<span class="type">const</span> Obj1 &amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj1(const Obj1&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj1</span>(Obj1 &amp;&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj1(Obj1&amp;&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj2</span>(<span class="type">const</span> Obj2 &amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj2(const Obj2&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Obj2</span>(Obj2 &amp;&amp;) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Obj2(Obj2&amp;&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 区别：Obj2的移动构造函数声明为noexcept</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Obj1&gt; v1;</span><br><span class="line">    v1.<span class="built_in">reserve</span>(<span class="number">2</span>);</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>();</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>();</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;Obj2&gt; v2;</span><br><span class="line">    v2.<span class="built_in">reserve</span>(<span class="number">2</span>);</span><br><span class="line">    v2.<span class="built_in">emplace_back</span>();</span><br><span class="line">    v2.<span class="built_in">emplace_back</span>();</span><br><span class="line">    v2.<span class="built_in">emplace_back</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Obj1()</span><br><span class="line">Obj1()</span><br><span class="line">Obj1()</span><br><span class="line">Obj1(const Obj1&amp;)</span><br><span class="line">Obj1(const Obj1&amp;)</span><br><span class="line">Obj2()</span><br><span class="line">Obj2()</span><br><span class="line">Obj2()</span><br><span class="line">Obj2(Obj2&amp;&amp;)</span><br><span class="line">Obj2(Obj2&amp;&amp;)</span><br></pre></td></tr></table></figure>

<p>运行结果：Obj1扩容使用拷贝构造，Obj2扩容使用移动构造</p>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a><code>deque</code></h4><ul>
<li>双端队列</li>
<li>为头尾高效增删元素而优化</li>
</ul>
<p><strong>deque的内存布局</strong></p>
<p><img src="/../assets/C-%E5%AE%B9%E5%99%A8%E5%92%8C%E7%B1%BB%E5%AE%B9%E5%99%A8/image-20240814144709712.png" alt="image-20240814144709712"></p>
<p>跟 <code>vector</code> 相比的优点：头尾插入的时候不会涉及额外的移动操作，只需要创建一个新的内存块，只有当索引存储不够时才需要移动索引存储，所以当需要在头尾频繁插入数据时，<code>deque</code>是一个性能很高的选择</p>
<p><strong>deque的特点</strong></p>
<ol>
<li>只从头尾进行增删时，容器里的对象永远不需要移动</li>
<li>容器里的元素只是部分连续</li>
<li>元素的存储大部分仍然连续，遍历性能较高</li>
<li>支持使用<strong>下标</strong>访问容器元素，仍能保持O(1)</li>
</ol>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a><code>list</code></h4><ul>
<li>双向链表</li>
<li>为任意位置插入和删除优化</li>
</ul>
<p><strong>list内存布局</strong>：同理，begin和front指向首，back指向尾，end指向尾+1</p>
<p><strong>list的特点</strong></p>
<ol>
<li>提供高效的、O(1)复杂度的任意位置的插入和删除操作</li>
<li>不支持使用下标访问元素</li>
<li>不支持 <code>sort</code> 算法，但能使用其成员函数 <code>sort</code>，例：<code>sort(list.begin(),list.end())</code>错误，正确：<code>list.sort()</code></li>
</ol>
<h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a><code>forward_list</code></h4><ul>
<li>单向链表</li>
<li>比 <code>list</code>少了前继结点，比 <code>list</code> 内存占用少</li>
</ul>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a><code>queue</code></h4><ul>
<li>先进先出的容器适配器</li>
<li>底层默认使用 <code>deque</code>，也可以是 <code>list</code></li>
<li>不能按下标访问，只能从首部弹出，尾部添加</li>
</ul>
<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a><code>stack</code></h4><ul>
<li>后进先出的容器适配器</li>
<li>底层默认使用 <code>deque</code>，也可以是 <code>list</code>、<code>vector</code></li>
</ul>
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><code>priority_queue</code></h4><ul>
<li><p>优先级队列（部分排序的队列），排序的部分在顶部</p>
</li>
<li><p>默认使用 <code>less</code> 排序</p>
</li>
<li><p>排序的末项在顶部，默认是大根堆</p>
</li>
<li><pre><code class="C++">模板参数:
_Tp – Type of element.
_Sequence – Type of underlying sequence, defaults to vector&lt;_Tp&gt;.
_Compare – Comparison function object type, defaults to less&lt;_Sequence::value_type&gt;.

priority_queue&lt;int,vector&lt;int&gt;,my_greater&gt; que; // 函数 &quot;my_greater&quot; 不是类型名C/C++(757)
// 所以这里的参数也只能是函数对象
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">**函数对象 `less`**</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct less:binary_function&lt;T,T,bool&gt;&#123;</span><br><span class="line">    bool operator()(const T&amp; x,const T&amp; y)&#123;</span><br><span class="line">        return x&lt;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>函数对象：在<code>class</code>或<code>struct</code>中实现 <code>operator()</code> 的对象，生成这样一个对象之后，可以使用 <code>()</code> 来调用函数，行为跟普通函数有点区别</p>
<p>注意：<code>sort</code>可以接受函数指针作为参数，但是 <code>map</code> <code>set</code>只能接受函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">my_greater</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), my_greater);</span><br><span class="line"><span class="comment">// 5 4 3 2 </span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">// 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>, less&lt;<span class="type">int</span>&gt;&gt; set&#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 2 3 4 5 </span></span><br><span class="line">set&lt;<span class="type">int</span>, my_greater&gt; set&#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 报错：函数 &quot;my_greater&quot; 不是类型名C/C++(757)</span></span><br><span class="line">模板参数:</span><br><span class="line">_Key – Type of key objects.</span><br><span class="line">_Compare – Comparison function object type, defaults to less&lt;_Key&gt;.</span><br><span class="line">_Alloc – Allocator type, defaults to allocator&lt;_Key&gt;.</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><ul>
<li>有序的容器，默认使用 <code>less</code></li>
<li><code>set、map、multiset、multimap</code>：key是否可重复</li>
<li>查找、插入和删除的时间复杂度都是 <code>O(log N)</code></li>
</ul>
<h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><ul>
<li><p>容器元素间没有顺序关系</p>
</li>
<li><p>默认使用 <code>hash</code>，也可以使用自定义的函数对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;complex&lt;T&gt;&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> complex&lt;T&gt; &amp;v)</span><span class="type">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">        hash&lt;T&gt; h;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">h</span>(v.<span class="built_in">real</span>())+<span class="built_in">h</span>(v.<span class="built_in">imag</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>unordered_set、unordered_map、unordered_multiset、unordered_multimap</code>：key是否可重复</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/13/%E5%9B%BE/" class="post-title-link" itemprop="url">图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-13 16:26:02 / 修改时间：16:29:50" itemprop="dateCreated datePublished" datetime="2024-08-13T16:26:02+08:00">2024-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul>
<li>做题方法：选一个模板，实现所有的算法，遇到具体题目的时候，转化为自己熟悉的结构</li>
</ul>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul>
<li>找到入度为0的点进队</li>
<li>每出队一个点，就把该点的影响消除，把nexts的入度减一</li>
</ul>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>无向图，连通且权值和最小</p>
<h5 id="krusal算法"><a href="#krusal算法" class="headerlink" title="krusal算法"></a>krusal算法</h5><p>从边来找——&gt;最小的边min</p>
<p>看最小的边加上后是否成环</p>
<p>Q：如何判断是否成环</p>
<p>A：看边连接的两个点是否属于两个集合 哈希map（点，点所在的集合）</p>
<h5 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h5><ul>
<li>最小生成堆</li>
<li>每次从解锁的边里选最短的，并且点to未访问</li>
<li>将边cur加入结果，点to加入visited，将点to相邻的边加入小顶堆</li>
</ul>
<h4 id="最小路径—Dijkstra算法"><a href="#最小路径—Dijkstra算法" class="headerlink" title="最小路径—Dijkstra算法"></a>最小路径—Dijkstra算法</h4><ul>
<li>初始化<ul>
<li>distanceMap &lt;node* ,int&gt;：指定点到每一个点的距离<ul>
<li>先加入&lt;head,0&gt;</li>
</ul>
</li>
<li>selectedNodes &lt;node*&gt;：已经访问过的点，即距离已确定，无需再修改</li>
</ul>
</li>
<li>从distanceMap里选择距离最小且未访问的——&gt;minnode<ul>
<li>遍历Minnie的边集（从minnode出来的边）<ul>
<li>如果distanceMap里没有点to的记录，就加入（点to，distance+weight）</li>
<li>如果有的话，就加入（点to，min{distance+weight，点to的距离}）</li>
</ul>
</li>
<li>把minnode加入selected</li>
<li>找minnode，循环</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/13/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">二叉树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-13 16:25:51" itemprop="dateCreated datePublished" datetime="2024-08-13T16:25:51+08:00">2024-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-14 17:22:30" itemprop="dateModified" datetime="2024-08-14T17:22:30+08:00">2024-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基础遍历"><a href="#基础遍历" class="headerlink" title="基础遍历"></a>基础遍历</h3><h4 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4><p>例：         1</p>
<p>​			2		3</p>
<p>​	4		5	6		7	</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Order</span><span class="params">(node *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==null) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//(1)</span></span><br><span class="line">    <span class="built_in">Order</span>(head-&gt;left);</span><br><span class="line">    <span class="comment">//(2)</span></span><br><span class="line">    <span class="built_in">Order</span>(head-&gt;right);</span><br><span class="line">    <span class="comment">//(3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归序(访问结点的顺序)：1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;head-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//打印语句位置</span></span><br></pre></td></tr></table></figure>

<p>先序遍历：第一次访问打印 (1)</p>
<p>中序遍历：第二次访问打印(2)</p>
<p>后序遍历：第三次访问打印(3)</p>
<h4 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h4><p>三种遍历都是用的栈</p>
<h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p>
<ol>
<li>头先进栈</li>
<li>当栈不为空，弹出cur<ol>
<li>打印cur</li>
<li>cur右进栈，左进栈</li>
</ol>
</li>
</ol>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p>
<ol>
<li>头先进栈</li>
<li>当栈不为空，弹出cur<ol>
<li>打印cur</li>
<li>cur左进栈，右进栈</li>
</ol>
</li>
<li>翻转数组</li>
</ol>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p>
<ol>
<li>整棵树左边界进栈</li>
<li>弹出，打印cur</li>
<li>cur右子树的左边界进栈</li>
</ol>
<h3 id="宽度优先遍历-层次遍历"><a href="#宽度优先遍历-层次遍历" class="headerlink" title="宽度优先遍历&#x2F;层次遍历"></a>宽度优先遍历&#x2F;层次遍历</h3><p>宽度优先遍历用队列</p>
<ol>
<li>头结点先进队</li>
<li>循环<ol>
<li>弹出就打印cur</li>
<li>先放左再放右</li>
</ol>
</li>
</ol>
<h4 id="求二叉树最大宽度"><a href="#求二叉树最大宽度" class="headerlink" title="求二叉树最大宽度"></a>求二叉树最大宽度</h4><ul>
<li><p>法1：哈希表：（head，1）&#x2F;&#x2F;第一层</p>
<p>curlevel,curlevelnode,max</p>
<p>弹出结点&#x3D;当前层，node++</p>
<p>else 说明进入下一层了</p>
<p>——&gt;需要一个哈希表，进队列的时候(left，level+1);</p>
</li>
<li><p>法2：队列</p>
</li>
</ul>
<h3 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h3><h4 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h4><p>每一个节点大于左子树，小于右子树</p>
<p>判断：中序遍历，输出一定是升序</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>任何节点左树和右树的高度差都不超过1</p>
<h3 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h3><ol>
<li>列出所有的可能性</li>
<li>整理需要左树、右树提供的信息，封装为结构体，作为返回值（左右子树返回值得是一样的）</li>
<li>函数结构<ol>
<li>空树情况（如果情况比较奇怪，返回NULL，调用的时候再讨论）</li>
<li>处理左树，处理右树</li>
<li>根据左右子树信息，处理本树</li>
<li>返回</li>
</ol>
</li>
</ol>
<blockquote>
<p>递归套路可以解决一切树型dp问题：问题可以通过向左子树和右子树要信息解决</p>
<p>但要具体问题具体分析，也不是所有问题都能用套路</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/13/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-13 16:24:57 / 修改时间：16:28:44" itemprop="dateCreated datePublished" datetime="2024-08-13T16:24:57+08:00">2024-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="unordered-map的使用"><a href="#unordered-map的使用" class="headerlink" title="unordered_map的使用"></a>unordered_map的使用</h4><p>既有key又有value就是map结构</p>
<ol>
<li><p>头文件：</p>
<p><code>#include&lt; unordered_map&gt;</code></p>
</li>
<li><p>定义一个哈希表(我们以Key和Value都是int变量为例)</p>
<p><code>unordered_map&lt;int,int&gt; Hash;</code></p>
</li>
<li><p>哈希表的建立有下面几种方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hash[<span class="number">1</span>]=<span class="number">3</span>;</span><br><span class="line">Hash.insert&lt;<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">3</span>)&gt;;</span><br><span class="line">Hash.<span class="built_in">insert</span>(&#123; &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器</p>
<p><code>unordered_map&lt;int,int&gt;::iterator it;</code></p>
</li>
<li><p>利用迭代器访问变量</p>
<p><code>it-&gt;first; it-&gt;second;</code></p>
</li>
<li><p>哈希表的查找</p>
<p><code>it=Hash.find(1);</code></p>
</li>
<li><p>修改哈希表</p>
<p><code>Hash[1] = 4;</code></p>
</li>
<li><p>清除哈希表</p>
<p><code>Hash.erase(1); Hash.clear();</code></p>
</li>
</ol>
<blockquote>
<ul>
<li><p>放入哈希表的东西：</p>
<p>如果是基础类型，内部按值传递，内存占用就是这个东西的大小，如int，string</p>
<p>Eg：<code>unordered_map&lt;int,int&gt; Hash;unordered_map&lt;string,string&gt; Hash;Hash.insert&lt;make_pair(&quot;ssdefefrf&quot;,3)&gt;</code></p>
<p>​	string多大则哈希表多大，是把值直接拷贝到哈希表</p>
<p>如果不是基础类型，内部按引用传递，内存大小就是这个东西内存地址大小，即8字节，如自定义的node</p>
<p>​	不管node多大，哈希表里存放的就是node的地址</p>
</li>
<li><p>哈希表的增删查改操作都是常数级</p>
</li>
</ul>
</blockquote>
<h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><p>哈希表能实现的功能，有序表都能实现</p>
<p>并且有序表的key按某种规则有序组织</p>
<p>有序表的增删查改操作都是O(logN)</p>
<blockquote>
<p>放入有序表的东西：</p>
<p>如果是基础类型，内部按值传递，内存占用就是这个东西的大小</p>
<p>如果不是基础类型，内部按引用传递，内存大小就是这个东西内存地址大小，即8字节，并且必须提供比较器</p>
</blockquote>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>链表由一系列结点组成</p>
<p>结点&#x3D;数据+下一个结点的指针</p>
<p>链表的特点：</p>
<blockquote>
<ol>
<li>存储空间可连续也可不连续</li>
<li>链表的存取通过头节点开始</li>
<li>是非随机存取的存储结构</li>
</ol>
</blockquote>
<p>链表的插入方式</p>
<p><img src="/../assets/%E9%93%BE%E8%A1%A8/image-20240321161019496.png" alt="image-20240321161019496"></p>
<p>插在头节点前还是头节点后</p>
<ol>
<li><p>头插法</p>
<p><code>new-&gt;next=head;head=new;</code></p>
</li>
<li><p>尾插法</p>
<p><code>new-&gt;next=head-&gt;next;head-&gt;next=new;</code></p>
</li>
</ol>
<h4 id="单链表的结构"><a href="#单链表的结构" class="headerlink" title="单链表的结构"></a>单链表的结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表类的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sLinkList</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="comment">//单链表中的结点类</span></span><br><span class="line">		elemType data;</span><br><span class="line">		node *next;</span><br><span class="line">		<span class="built_in">node</span>(<span class="type">const</span> elemType &amp;x,node *n=<span class="literal">NULL</span>)&#123;<span class="comment">//结点构造函数</span></span><br><span class="line">			data=x;</span><br><span class="line">			next=n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">node</span>():<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//*</span></span><br><span class="line">		~<span class="built_in">node</span>()&#123;&#125;;<span class="comment">//注意要写实现</span></span><br><span class="line">	&#125;;</span><br><span class="line">	node *head;</span><br><span class="line">	<span class="type">int</span> currentLength;</span><br><span class="line">	<span class="function">node *<span class="title">move</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;<span class="comment">//返回第i个结点的位置</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">sLinkList</span>();</span><br><span class="line">	~<span class="built_in">sLinkList</span>()&#123;</span><br><span class="line">		<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">delete</span> head;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> currentLength;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i,<span class="type">const</span> elemType &amp;x)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> elemType &amp;x)</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function">elemType <span class="title">visit</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">sLinkList&lt;elemType&gt;::<span class="built_in">sLinkList</span>()&#123;</span><br><span class="line">	head=<span class="keyword">new</span> node;</span><br><span class="line">	currentLength=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除线性表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sLinkList&lt;elemType&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">	node *p=head-&gt;next,*q;</span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		q=p-&gt;next;<span class="comment">//先记录p下一个结点</span></span><br><span class="line">		<span class="keyword">delete</span> p;<span class="comment">//再删除p</span></span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">	currentLength=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第i个元素的指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> sLinkList&lt;elemType&gt;::node *sLinkList&lt;elemType&gt;::<span class="built_in">move</span>(<span class="type">int</span> i) <span class="type">const</span>&#123;</span><br><span class="line">	node *p=head;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在i处插入x</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sLinkList&lt;elemType&gt;::<span class="built_in">insert</span>(<span class="type">int</span> i,<span class="type">const</span> elemType &amp;x)&#123;</span><br><span class="line">	<span class="comment">//i-1处的下一个结点是x</span></span><br><span class="line">	node *pos=<span class="built_in">move</span>(i<span class="number">-1</span>);</span><br><span class="line">	pos-&gt;next=<span class="keyword">new</span> <span class="built_in">node</span>(x,pos-&gt;next);</span><br><span class="line">	currentLength++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sLinkList&lt;elemType&gt;::<span class="built_in">remove</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">	<span class="comment">//i-1处的下一个结点是i+1处</span></span><br><span class="line">	node *pos=<span class="built_in">move</span>(i<span class="number">-1</span>);</span><br><span class="line">	node *del=pos-&gt;next;</span><br><span class="line">	pos-&gt;next=del-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> del;</span><br><span class="line">	currentLength--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索线性表中是否出现x，找不到返回-1，找到返回x的下标</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> sLinkList&lt;elemType&gt;::<span class="built_in">search</span>(<span class="type">const</span> elemType &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">	node *p=head-&gt;next;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;currentLength;i++,p=p-&gt;next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data==x) <span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问线性表的第i个元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">elemType sLinkList&lt;elemType&gt;::<span class="built_in">visit</span>(<span class="type">int</span> i)<span class="type">const</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">move</span>(i)-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历运算</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sLinkList&lt;elemType&gt;::<span class="built_in">traverse</span>()<span class="type">const</span>&#123;</span><br><span class="line">	node *p=head-&gt;next;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;currentLength;i++,p=p-&gt;next)&#123;</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">sLinkList&lt;<span class="type">int</span>&gt; list;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>每个结点附加了两个指针字段，previous：前驱节点的地址，next：后继节点的地址</p>
<p>头节点：previous&#x3D;NULL，next&#x3D;a[0]</p>
<p>尾结点：previous&#x3D;a[末]，next&#x3D;NULL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dLinkList</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="comment">//双链表的结点类</span></span><br><span class="line">		node *prev,*next;</span><br><span class="line">		elemType data;</span><br><span class="line">		<span class="built_in">node</span>(<span class="type">const</span> elemType &amp;x,node *p=<span class="literal">NULL</span>,node *n=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			data=x;prev=p;next=n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">node</span>():<span class="built_in">prev</span>(<span class="literal">NULL</span>),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">		~<span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	node *head,*tail;</span><br><span class="line">	<span class="type">int</span> currentLength;</span><br><span class="line">	<span class="function">node *<span class="title">move</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//返回i位置的结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">dLinkList</span>();</span><br><span class="line">	~<span class="built_in">dLinkList</span>()&#123;</span><br><span class="line">		<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">delete</span> head;</span><br><span class="line">		<span class="keyword">delete</span> tail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> currentLength;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i,elemType &amp;x)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> elemType &amp;x)</span></span>;</span><br><span class="line">	<span class="function">elemType <span class="title">visit</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">dLinkList&lt;elemType&gt;::<span class="built_in">dLinkList</span>()&#123;</span><br><span class="line">	head=<span class="keyword">new</span> node;</span><br><span class="line">	tail=<span class="keyword">new</span> node;</span><br><span class="line">	head-&gt;next=tail;</span><br><span class="line">	tail-&gt;prev=head;</span><br><span class="line">	currentLength=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> dLinkList&lt;elemType&gt;::node *dLinkList&lt;elemType&gt;::<span class="built_in">move</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">	node *p=head;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> dLinkList&lt;elemType&gt;::<span class="built_in">insert</span>(<span class="type">int</span> i,elemType &amp;x)&#123;</span><br><span class="line">	node *pos=<span class="built_in">move</span>(i<span class="number">-1</span>);<span class="comment">//a[i-1]</span></span><br><span class="line">	node *next=pos-&gt;next;<span class="comment">//a[i]</span></span><br><span class="line">	node *tmp=<span class="keyword">new</span> <span class="built_in">node</span>(x,pos,next);</span><br><span class="line">	pos-&gt;next=tmp;</span><br><span class="line">	next-&gt;prev=tmp;</span><br><span class="line">	currentLength++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> dLinkList&lt;elemType&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">	node *p=head-&gt;next,*q;</span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		q=p-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">delete</span> q;</span><br><span class="line">	<span class="keyword">delete</span> head;</span><br><span class="line">	currentLength=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> dLinkList&lt;elemType&gt;::<span class="built_in">remove</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">	node *pos=<span class="built_in">move</span>(i<span class="number">-1</span>);</span><br><span class="line">	node *del=pos-&gt;next;<span class="comment">//a[i]</span></span><br><span class="line">	node *next=del-&gt;next;</span><br><span class="line">	pos-&gt;next=next;</span><br><span class="line">	next-&gt;prev=pos;</span><br><span class="line">	<span class="keyword">delete</span> del;</span><br><span class="line">	currentLength--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">int</span> dLinkList&lt;elemType&gt;::<span class="built_in">search</span>(<span class="type">const</span> elemType &amp;x)&#123;</span><br><span class="line">	node *p=head-&gt;next;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;currentLength;i++,p=p-&gt;next)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data==x) <span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line">elemType dLinkList&lt;elemType&gt;::<span class="built_in">visit</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">move</span>(i)-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;	</span><br><span class="line"><span class="type">void</span> dLinkList&lt;elemType&gt;::<span class="built_in">traverse</span>()&#123;</span><br><span class="line">	node *p=head-&gt;next;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;currentLength;i++,p=p-&gt;next)&#123;</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>一般单循环链表不设头节点，双循环链表不设头尾结点</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>笔试：只要求时间复杂度</p>
<p>面试：时间复杂度优先，空间复杂度尽可能小</p>
<p>技巧：1、额外数据结构记录；2、快慢指针</p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></h4><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<ul>
<li><p>不要求空间</p>
<ul>
<li><p>准备一个栈，遍历链表进栈，出栈&#x3D;&#x3D;原链表——&gt;回文链表</p>
</li>
<li><p>改进：让链表右边一半进栈</p>
<ul>
<li><p>Q：怎么知道右边一半开始</p>
<p>A：准备两个指针，慢指针一次走一步，快指针一次走两步，注意边界条件</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>要求空间复杂度</p>
<ul>
<li>准备快慢指针，当慢指针走到中间的时候，把后面的链表逆序，然后一块从两头向中间遍历，最后恢复链表</li>
</ul>
</li>
<li><p>将单向链表按某值划分为左边小、中间相等、右边大的形式</p>
<ul>
<li><p>要求低</p>
<ul>
<li><p>定义一个node型的数组，进行partition，再串起来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sLinkList&lt;elemType&gt;::<span class="built_in">partition</span>(<span class="type">int</span> aim)&#123;</span><br><span class="line">	node *arr[currentLength];</span><br><span class="line">	node *pos=head-&gt;next;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;currentLength;i++)&#123;</span><br><span class="line">		arr[i]=pos;</span><br><span class="line">		pos=pos-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,low=<span class="number">-1</span>,high=currentLength;</span><br><span class="line">	node *temp;</span><br><span class="line">	<span class="keyword">while</span>(i!=high)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]-&gt;data&lt;aim)&#123;</span><br><span class="line">			temp=arr[i];</span><br><span class="line">			arr[i]=arr[low+<span class="number">1</span>];</span><br><span class="line">			arr[low+<span class="number">1</span>]=temp;</span><br><span class="line">			low++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]-&gt;data==aim)&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]-&gt;data&gt;aim)&#123;</span><br><span class="line">			temp=arr[i];</span><br><span class="line">			arr[i]=arr[high<span class="number">-1</span>];</span><br><span class="line">			arr[high<span class="number">-1</span>]=temp;</span><br><span class="line">			high--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	head-&gt;next=arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;currentLength<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		arr[i]-&gt;next=arr[i+<span class="number">1</span>];</span><br><span class="line">	&#125;	</span><br><span class="line">	arr[currentLength<span class="number">-1</span>]-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>要求高</p>
<ul>
<li><p>定义六个变量，小于等于大于三个区域的头和尾，最后再连起来</p>
<ul>
<li>此时的partition具有稳定性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">elemType</span>&gt;</span><br><span class="line"><span class="type">void</span> sLinkList&lt;elemType&gt;::<span class="built_in">partition</span>(<span class="type">int</span> aim)&#123;</span><br><span class="line">	node *sh=<span class="literal">NULL</span>;</span><br><span class="line">	node *st=<span class="literal">NULL</span>;</span><br><span class="line">	node *mh=<span class="literal">NULL</span>;</span><br><span class="line">	node *mt=<span class="literal">NULL</span>;</span><br><span class="line">	node *bh=<span class="literal">NULL</span>;</span><br><span class="line">	node *bt=<span class="literal">NULL</span>;</span><br><span class="line">	node *pos=head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(pos!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(pos-&gt;data&lt;aim)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sh==<span class="literal">NULL</span>)&#123;</span><br><span class="line">				sh=pos;</span><br><span class="line">				st=pos;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				st-&gt;next=pos;</span><br><span class="line">				st=pos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pos-&gt;data==aim)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mh==<span class="literal">NULL</span>)&#123;</span><br><span class="line">				mh=pos;</span><br><span class="line">				mt=pos;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				mt-&gt;next=pos;</span><br><span class="line">				mt=pos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pos-&gt;data&gt;aim)&#123;</span><br><span class="line">			<span class="keyword">if</span>(bh==<span class="literal">NULL</span>)&#123;</span><br><span class="line">				bh=pos;</span><br><span class="line">				bt=pos;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				bt-&gt;next=pos;</span><br><span class="line">				bt=pos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pos=pos-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	st-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	mt-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	bt-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//将三个区域连起来，注意讨论区域为空的情况</span></span><br><span class="line">	<span class="keyword">if</span>(sh==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(mh==<span class="literal">NULL</span>) head-&gt;next=bh;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			head-&gt;next=mh;</span><br><span class="line">			<span class="keyword">if</span>(bh==<span class="literal">NULL</span>) mt-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				mt-&gt;next=bh;</span><br><span class="line">				bt-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		head-&gt;next=sh;</span><br><span class="line">		<span class="keyword">if</span>(mh==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(bh==<span class="literal">NULL</span>) st-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				st-&gt;next=bh;</span><br><span class="line">				bt-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			st-&gt;next=mh;</span><br><span class="line">			<span class="keyword">if</span>(bh==<span class="literal">NULL</span>) mt-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				mt-&gt;next=bh;</span><br><span class="line">				bt-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/">随机链表的复制</a></h4><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<p><code>val</code>：一个表示 <code>Node.val</code> 的整数。</p>
<p><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</p>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<ul>
<li><p>要求低：可以使用额外空间，哈希表</p>
<ul>
<li><p>哈希表的key&#x3D;node(old),value&#x3D;node(new)</p>
<p>（1）的next指向（2），则value(1)的next指向value（2）</p>
</li>
</ul>
</li>
<li><p>要求高：不使用哈希表</p>
<ul>
<li>克隆新节点挂在旧结点后面，加上rand指针，old-&gt;next-&gt;rand&#x3D;old-&gt;rand</li>
<li>分离新旧链表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="两个单链表相交的一系列问题"><a href="#两个单链表相交的一系列问题" class="headerlink" title="两个单链表相交的一系列问题"></a>两个单链表相交的一系列问题</h4><p>题目：给定两个可能有环也可能无环的单链表，头节点head1&#x2F;2，函数：若相交返回相交的第一个结点，若不相交，返回null</p>
<p>要求：链表长度之和为N，时间复杂度：O(N)，空间复杂度：O(1)</p>
<h5 id="1-判断环"><a href="#1-判断环" class="headerlink" title="1.判断环"></a>1.判断环</h5><ul>
<li>使用哈希<ul>
<li>准备一个set，遍历，set中有无，无则放入，有则说明是入环结点</li>
</ul>
</li>
<li>快慢指针，初始都在头节点，慢指针走一步，快指针走两步<ul>
<li>快指针&#x3D;null——&gt;无环</li>
<li>若有环，则快慢指针一定会相遇<ol>
<li>让快指针回到头节点</li>
<li>快慢指针每次移动一步，则快慢指针相遇的地方就是入环结点</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="2-判相交结点"><a href="#2-判相交结点" class="headerlink" title="2.判相交结点"></a>2.判相交结点</h5><ul>
<li>两个都无环<ul>
<li>if end1!&#x3D;end2 不相交</li>
<li>else 从长链表中*位开始往后走，短链表从头往后中，可得相交结点##</li>
</ul>
</li>
<li>一个有环一个无环，一定不相交</li>
<li>两个都有环<ul>
<li>loop1？&#x3D;loop2<ul>
<li>&#x3D;，复用##</li>
<li>！&#x3D;，从loop1能不能走到loop2<ul>
<li>不能，不相交</li>
<li>能，loop1和loop2都是相交结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/O-Nlog-N-%E7%9A%84%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/13/O-Nlog-N-%E7%9A%84%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">O(Nlog N)的排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-13 16:24:47 / 修改时间：16:27:58" itemprop="dateCreated datePublished" datetime="2024-08-13T16:24:47+08:00">2024-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="O-NlogN-的排序"><a href="#O-NlogN-的排序" class="headerlink" title="O(NlogN)的排序"></a>O(NlogN)的排序</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(arr,l,mid);</span><br><span class="line">	<span class="built_in">sort</span>(arr,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">merge</span>(arr,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p1=left,p2=mid+<span class="number">1</span>,current=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> result[right-left+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=right)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[p1]&lt;=arr[p2])&#123;</span><br><span class="line">			result[current++]=arr[p1++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			result[current++]=arr[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p1&lt;=mid) result[current++]=arr[p1++];</span><br><span class="line">	<span class="keyword">while</span>(p2&lt;=right) result[current++]=arr[p2++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">		arr[left+i]=result[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(NlogN)</p>
<p>时间复杂度比插入选择排序小，因为原来的比较n次只得到一个结果，下一轮重新开始比较，而归并排序把每一次的比较结果都传递给了下一轮；</p>
<p>空间复杂度大，因为多定义了一个数组</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h5><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p1=left,p2=mid+<span class="number">1</span>,current=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> result[right-left+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=right)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[p1]&lt;arr[p2])&#123;</span><br><span class="line">			sum=sum+arr[p1]*(right-p2+<span class="number">1</span>);</span><br><span class="line">			result[current++]=arr[p1++];	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(arr[p1]&gt;arr[p2])&#123;</span><br><span class="line">			result[current++]=arr[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> result[current++]=arr[p2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(p1&lt;=mid) result[current++]=arr[p1++];</span><br><span class="line">	<span class="keyword">while</span>(p2&lt;=right) result[current++]=arr[p2++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">		arr[left+i]=result[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SmallSum</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">SmallSum</span>(arr,l,mid)+<span class="built_in">SmallSum</span>(arr,mid+<span class="number">1</span>,r)+<span class="built_in">merge</span>(arr,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSmallSum</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">SmallSum</span>(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h5><p>在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请输出逆序对的个数。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LCR 170. 交易逆序对的总数</a></p>
<p>在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 <code>record</code>，返回其中存在的「交易逆序对」总数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mergeReverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; record,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p1=left,p2=mid+<span class="number">1</span>,p=<span class="number">0</span>,result=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> help[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(record[p1]&gt;record[p2])&#123;</span><br><span class="line">            result=result+(right-p2+<span class="number">1</span>);</span><br><span class="line">            help[p]=record[p1];</span><br><span class="line">            p++;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            help[p]=record[p2];</span><br><span class="line">            p++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid)&#123;</span><br><span class="line">        help[p]=record[p1];</span><br><span class="line">        p++;</span><br><span class="line">        p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;=right)&#123;</span><br><span class="line">        help[p]=record[p2];</span><br><span class="line">        p++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=right-left;i++)&#123;</span><br><span class="line">        record[left+i]=help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getReverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; record,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getReverse</span>(record,left,mid)+<span class="built_in">getReverse</span>(record,mid+<span class="number">1</span>,right)+<span class="built_in">mergeReverse</span>(record,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; record)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(record.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getReverse</span>(record,<span class="number">0</span>,record.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><h4 id="快排1-0"><a href="#快排1-0" class="headerlink" title="快排1.0"></a>快排1.0</h4><p><u>小于等于num</u> + <u>大于num</u></p>
<p>时间复杂度：O(N^2)，原因：划分值num打的很偏，导致只有一侧</p>
<h4 id="快排2-0"><a href="#快排2-0" class="headerlink" title="快排2.0"></a>快排2.0</h4><p><u>小于num</u> + <u>等于num</u> + <u>大于num</u></p>
<p>时间复杂度：O(N^2)，原因：划分值num打的很偏，导致只有一侧</p>
<h4 id="快排3-0"><a href="#快排3-0" class="headerlink" title="快排3.0"></a>快排3.0</h4><p>随机选择一个数与最后一位数做交换，再作为划分值——&gt;好情况和坏情况是概率事件，每种情况只占1&#x2F;N，求每种情况时间复杂度的数学期望</p>
<p>时间复杂度：O(NlogN)</p>
<p>空间复杂度：O(logN)  最差是O(N)  &lt;——递归（记录中点位置）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排，num,等于区域：p[0],p[1]</span></span><br><span class="line"><span class="comment">//[i]&lt;num,与小于边界的右边一位交换，i++，边界++</span></span><br><span class="line"><span class="comment">//[i]=num,i++</span></span><br><span class="line"><span class="comment">//[i]&gt;num,与大于边界的左边一位交换，边界--</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//返回等于区的左右边界</span></span><br><span class="line">	<span class="comment">//以最后一个数作为划分值</span></span><br><span class="line">	<span class="type">int</span> low=l<span class="number">-1</span>;<span class="comment">//小于区左边界</span></span><br><span class="line">	<span class="type">int</span> high=r;<span class="comment">//等于区右边界	</span></span><br><span class="line">	<span class="type">int</span> i=l;<span class="comment">//当前数的位置</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;high)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;arr[r])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr,i,low+<span class="number">1</span>);</span><br><span class="line">			low++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==arr[r])&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr,i,high<span class="number">-1</span>);</span><br><span class="line">			high--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(arr,high,r);</span><br><span class="line">	<span class="keyword">return</span> &#123;low+<span class="number">1</span>,high&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="comment">//随机选取一个数与最后一个数交换</span></span><br><span class="line">		<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">		<span class="type">int</span> idx=(<span class="built_in">rand</span>()%(r-l+<span class="number">1</span>))+l;</span><br><span class="line">		<span class="built_in">swap</span>(arr,idx,r);</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; p=<span class="built_in">partition</span>(arr,l,r);</span><br><span class="line">		<span class="built_in">quickSort</span>(arr,l,p[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">quickSort</span>(arr,p[<span class="number">1</span>]+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h4><h5 id="荷兰旗问题"><a href="#荷兰旗问题" class="headerlink" title="荷兰旗问题"></a>荷兰旗问题</h5><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></p>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<h3 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>完全二叉树：从上到下从左到右依次排满的过程</p>
<p>数据结构：从0开始的连续数组</p>
<p>父节点：(i-1)&#x2F;2</p>
<p>左节点：2i+1，右节点：2i+2</p>
<p>大根堆&#x2F;小根堆：根节点最大&#x2F;最小</p>
<p>Q：插入一个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插到数组最后，不断与父节点比较，若大于父节点则交换</span></span><br><span class="line"><span class="comment">//不断向上移动直到来到合适的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> idx)</span></span>&#123;<span class="comment">//让idx来到正确的位置</span></span><br><span class="line">	<span class="keyword">while</span>(arr[idx]&gt;arr[(idx<span class="number">-1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr,idx,(idx<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">		idx=(idx<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q：去掉最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把最后一个数移到根节点处，然后不断下移直到合适的位置</span></span><br><span class="line"><span class="comment">//下移：不断与左右节点最大的交换，直到没有子节点或者大于子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> idx,<span class="type">int</span> heapsize)</span></span>&#123;<span class="comment">//从idx开始下移</span></span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">2</span>*idx+<span class="number">1</span>&lt;heapsize)&#123;</span><br><span class="line">		max=<span class="number">2</span>*idx+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">2</span>*idx+<span class="number">2</span>&lt;heapsize&amp;&amp;arr[max]&lt;arr[<span class="number">2</span>*idx+<span class="number">2</span>])&#123;</span><br><span class="line">			max=<span class="number">2</span>*idx+<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(arr[max]&lt;arr[idx]) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">swap</span>(arr,idx,max);</span><br><span class="line">		idx=max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建大根堆，一个个插入</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">heapInsert</span>(arr,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> heapSize=n;</span><br><span class="line">    <span class="comment">//arr[0]跟arr[末]交换=最大值来到了最后</span></span><br><span class="line">	<span class="built_in">swap</span>(arr,<span class="number">0</span>,heapSize<span class="number">-1</span>);</span><br><span class="line">	heapSize--;</span><br><span class="line">	<span class="keyword">while</span>(heapSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">heapify</span>(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">		<span class="built_in">swap</span>(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(NlogN)</p>
<p>空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建大根堆的优化：从下往上从右往左不断heapify</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="built_in">heapify</span>(nums,i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>Q：员工年龄排序（0~200）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i位置表示i岁的员工个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num[<span class="number">200</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		num[arr[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">200</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(num[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			num[i]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">in</span><br></pre></td></tr></table></figure>

<p>局限性：不基于比较的排序，取决于数据状态，比如说年龄范围0~200，准备num[200]，所以得知道数范围</p>
<h4 id="基数排序-桶排序"><a href="#基数排序-桶排序" class="headerlink" title="基数排序&#x2F;桶排序"></a>基数排序&#x2F;桶排序</h4><p>Eg：[17,13,25,100,72]</p>
<ol>
<li><p>补全[017,013,025,100,072]</p>
</li>
<li><p>准备十个桶，几进制就几个桶</p>
</li>
<li><p>按个位进桶</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td></td>
<td>072</td>
<td>013</td>
<td></td>
<td>025</td>
<td></td>
<td>017</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>先进先出，按个位出桶[100,072,013,025,017]</p>
</li>
<li><p>按十位进桶</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>013<br />017</td>
<td>025</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>072</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>先进先出，按十位出桶[100,013,017,025,072]</p>
</li>
<li><p>按百位进桶</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>013<br />017<br />025<br />072</td>
<td>100</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>先进先出，按百位出桶[013,017,025,072,100]</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/13/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">简单排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-13 16:24:16 / 修改时间：16:27:10" itemprop="dateCreated datePublished" datetime="2024-08-13T16:24:16+08:00">2024-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>时间复杂度：O(N^2)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minidx,temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    minidx=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[minidx]&gt;arr[j]) minidx=j;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=arr[i];</span><br><span class="line">    arr[i]=arr[minidx];</span><br><span class="line">    arr[minidx]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>时间复杂度：O(N^2)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>;<span class="comment">//是否冒泡</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            temp=arr[j];</span><br><span class="line">            arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>异或：相同为0，不同为1 &#x3D; 不进位相加</p>
</li>
<li><p>性质：</p>
<ol>
<li><p>0^N &#x3D; N ;N^N &#x3D; 0</p>
</li>
<li><p>满足交换律和结合律 a^b&#x3D;b^a;a^b^c&#x3D;a^(b^c)</p>
<p><code>a=a^b;b=a^b;a=a^b;</code> </p>
<p>跑完的结果：a、b交换；前提：a和b在内存中是两块独立的空间，即a指向的内存 !&#x3D; b指向的内存</p>
<p>eg:<code>a[0]=a[0]^a[0];a[0]=a[0]^a[0];a[0]=a[0]^a[0];</code></p>
<p>结果：a[0]变成0</p>
</li>
</ol>
<p>	</p>
</li>
<li><p>异或相关题目</p>
<p>Q：在一个整型数组中，只有一个数出现了奇数次，其他数都出现了偶数次</p>
<p>要求：时间复杂度O（N），空间复杂度O（1）：即使用有限几个变量</p>
<ol>
<li><p>怎么找到这个这个出现了奇数次的数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全部异或</span></span><br><span class="line"><span class="type">int</span> answer=arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    answer=answer^arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若只有两个数出现了奇数次呢</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    temp=temp^arr[i];</span><br><span class="line">&#125;<span class="comment">//temp=a^b!=0——&gt;temp至少有一位是1</span></span><br><span class="line"><span class="type">int</span> rightOne=temp&amp;(~temp+<span class="number">1</span>);<span class="comment">//原码&amp;补码得到最右侧的1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((arr[i]&amp;rightOne)==rightOne)&#123;<span class="comment">//在某位上为1的才参加异或</span></span><br><span class="line">        temp1=temp1^arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> answer1=temp1;</span><br><span class="line"><span class="type">int</span> answer2=temp^temp1;</span><br></pre></td></tr></table></figure>

<p>ps：<code>int rightOne=temp&amp;(~temp+1);</code>&#x2F;&#x2F;原码&amp;补码得到最右侧的1</p>
</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思想：将新的数插到原来有序数组中合适的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="comment">//0~i-1为有序，0~i为想有序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;arr[j+<span class="number">1</span>];j--)&#123;</span><br><span class="line">        tmp=arr[j];</span><br><span class="line">        arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h4 id="有序数组中找某个数是否存在"><a href="#有序数组中找某个数是否存在" class="headerlink" title="有序数组中找某个数是否存在"></a>有序数组中找某个数是否存在</h4><p>二分查找，时间复杂度 O（log N）</p>
<h4 id="有序数组中找-某个数最左侧的位置"><a href="#有序数组中找-某个数最左侧的位置" class="headerlink" title="有序数组中找&gt;&#x3D;某个数最左侧的位置"></a>有序数组中找&gt;&#x3D;某个数最左侧的位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> aim=<span class="number">4</span>;<span class="comment">//找到大于等于3最左侧的索引</span></span><br><span class="line"><span class="type">int</span> low,mid,high,idx=n;<span class="comment">//idx记录答案索引</span></span><br><span class="line">low=<span class="number">0</span>;high=n;</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">    mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;aim)&#123;</span><br><span class="line">        low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;idx) idx=mid;</span><br><span class="line">        high=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部最小值问题"><a href="#局部最小值问题" class="headerlink" title="局部最小值问题"></a>局部最小值问题</h4><p>arr中，无序但任意相邻数不相等，求一个局部最小的位置，要求时间复杂度好于O（N）</p>
<p>局部最小def：0位置比1位置小 &#x2F; n-1位置比n-2位置小 &#x2F; i位置比i-1和i+1位置小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">判断<span class="number">0</span>位置和n<span class="number">-1</span>位置是否为局部最小</span><br><span class="line">若不存在，则<span class="number">0</span>↘↙n<span class="number">-1</span>，则<span class="number">0</span>~n<span class="number">-1</span>之间必存在局部最小 </span><br><span class="line">判断中间位置是否为局部最小，</span><br><span class="line">    若是则直接返回</span><br><span class="line">    若不是，</span><br><span class="line">    	<span class="keyword">if</span>(m<span class="number">-1</span>↗m↖m+<span class="number">1</span>) 则左右侧都存在局部最小</span><br><span class="line">        <span class="keyword">if</span>(m<span class="number">-1</span>↗m↗m+<span class="number">1</span>) 则左侧一定存在局部最小</span><br><span class="line">        <span class="keyword">if</span>(m<span class="number">-1</span>↘m↘m+<span class="number">1</span>) 则右侧一定存在局部最小</span><br></pre></td></tr></table></figure>

<p>所以，二分法不一定只能用于有序数组，取决于研究的问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-13 15:56:11 / 修改时间：16:00:05" itemprop="dateCreated datePublished" datetime="2024-08-13T15:56:11+08:00">2024-08-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="有序表-并查集"><a href="#有序表-并查集" class="headerlink" title="有序表 并查集"></a>有序表 并查集</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>题目：一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起则成为一个岛，求一个矩阵中有几个岛</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line"><span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">这个矩阵有<span class="number">3</span>个岛</span><br></pre></td></tr></table></figure>

<p>【进阶】如何设计一个并行算法解决</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m=grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                result++;</span><br><span class="line">                <span class="built_in">inflect</span>(grid,m,n,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inflect</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid,<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=m||i&lt;<span class="number">0</span>||j&gt;=n||j&lt;<span class="number">0</span>||grid[i][j]!=<span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="built_in">inflect</span>(grid,m,n,i<span class="number">-1</span>,j);</span><br><span class="line">    <span class="built_in">inflect</span>(grid,m,n,i+<span class="number">1</span>,j);</span><br><span class="line">    <span class="built_in">inflect</span>(grid,m,n,i,j<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">inflect</span>(grid,m,n,i,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【进阶】&#x3D;&#x3D;&#x3D;》并查集</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>操作 ：</p>
<ol>
<li><code>bool isSameSet(a,b)</code></li>
<li><code>void union(a,b)</code></li>
</ol>
<p>很多结构都可以，但只有并查集两种操作的时间复杂度都是O(1)</p>
<ol>
<li><p><code>bool isSameSet(a,b)</code></p>
<p>判断a和b的父节点是否相同</p>
</li>
<li><p><code>void union(a,b)</code></p>
<p>判断a和b的父节点是否相同，若不同，个数少的集合的顶端挂在个数多的集合顶端之下</p>
</li>
</ol>
<p><code>findHead(Element a)</code>：往上走找代表结点</p>
<p><strong>改进：</strong>往上走的路径记录下来，路径上的结点直接指向父节点</p>
<p>结论：当<code>findHead</code>调用次数逼近或者大于O(N)，时间复杂度趋近于O(1)——越用越快</p>
<blockquote>
<p>C++11的for循环有了一种新的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> n : arr)&#123;</span><br><span class="line">	std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方式是<strong>只读</strong>，如果需要修改arr里边的值，可以使用<code>for(auto&amp; n:arr)</code>，for循环的这种使用方式的内在实现实际上还是借助迭代器的，所以如果在循环的过程中对arr进行了<del>增加和删除操作</del>，那么程序将对出现意想不到的错误。</p>
</blockquote>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFindSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">findHead</span><span class="params">(<span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">		stack&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">		<span class="keyword">while</span> (element != fatherMap.<span class="built_in">at</span>(element)) &#123;</span><br><span class="line">			path.<span class="built_in">push</span>(element);</span><br><span class="line">			element = fatherMap[element];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!path.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			fatherMap[path.<span class="built_in">top</span>()] = element;</span><br><span class="line">			path.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> element;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; fatherMap;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; sizeMap;</span><br><span class="line">	<span class="built_in">UnionFindSet</span>(list&lt;<span class="type">int</span>&gt; dataList) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> value : dataList) &#123;</span><br><span class="line">			set.<span class="built_in">emplace</span>(value);</span><br><span class="line">			fatherMap.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(value, value));</span><br><span class="line">			sizeMap.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(value, <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isSameSet</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (set.<span class="built_in">count</span>(a) &amp;&amp; set.<span class="built_in">count</span>(b)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">findHead</span>(a) == <span class="built_in">findHead</span>(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (set.<span class="built_in">count</span>(a) &amp;&amp; set.<span class="built_in">count</span>(b)) &#123;</span><br><span class="line">			<span class="type">int</span> afather = <span class="built_in">findHead</span>(a);</span><br><span class="line">			<span class="type">int</span> bfather = <span class="built_in">findHead</span>(b);</span><br><span class="line">			<span class="keyword">if</span> (afather != bfather) &#123;</span><br><span class="line">				<span class="type">int</span> big = sizeMap[afather] &gt;= sizeMap[bfather] ? afather : bfather;</span><br><span class="line">				<span class="type">int</span> small = big == afather ? bfather : afather;</span><br><span class="line">				fatherMap[small] = big;</span><br><span class="line">				sizeMap[big] = sizeMap[afather] + sizeMap[bfather];</span><br><span class="line">				sizeMap.<span class="built_in">erase</span>(small);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="进阶解法：设计一个并行算法解决"><a href="#进阶解法：设计一个并行算法解决" class="headerlink" title="进阶解法：设计一个并行算法解决"></a>进阶解法：设计一个并行算法解决</h3><img src="../assets/%E5%B9%B6%E6%9F%A5%E9%9B%86/image-20240624211209801.png" alt="image-20240624211209801" style="zoom:50%;" />

<p>问题：左右两个cpu分别感染，左侧cpu会识别两个岛，右侧cpu会识别两个岛，原因：破坏了岛的连通性</p>
<p>左右cpu分别计算的结果：4个岛，接下来进行合并</p>
<img src="../assets/%E5%B9%B6%E6%9F%A5%E9%9B%86/image-20240624211209801.png" alt="image-20240624211209801" style="zoom:50%;" />

<p><strong>合并方法：</strong></p>
<ol>
<li>记录初始感染点（图中绿色），记录边界上被感染点的初始感染点是谁（红色）</li>
<li>四个初始感染点，记为4个集合{A}{B}{C}{D}</li>
<li>比较在边界上相连的感染点<ol>
<li>感染点分别为A和C，不在一个集合，进行合并：{AC}{B}{D}，岛数&#x3D;4-1&#x3D;3</li>
<li>感染点为B和C，不在一个集合，进行合并：{ABC}{D}，岛数&#x3D;3-1&#x3D;2</li>
<li>感染点为B和D，不在一个集合，进行合并：{ABCD}，岛数&#x3D;2-1&#x3D;1</li>
<li>感染点为A和D，在一个集合，无需操作</li>
</ol>
</li>
<li>最后，总岛数&#x3D;1</li>
</ol>
<p>如果使用很多个CPU，同样的做法：每个CPU分别感染+记录边界上的感染点</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/13/C-11-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/13/C-11-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">C++:智能指针实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-13 15:52:06" itemprop="dateCreated datePublished" datetime="2024-08-13T15:52:06+08:00">2024-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-14 15:18:41" itemprop="dateModified" datetime="2024-08-14T15:18:41+08:00">2024-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>() &#123; <span class="keyword">delete</span> ptr_; &#125;</span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符，让行为更像指针</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    T *<span class="keyword">operator</span>&amp;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 禁止拷贝，至少可以防止double delete的行为</span></span><br><span class="line">    <span class="comment">// smart_ptr(const smart_ptr &amp;) = delete;</span></span><br><span class="line">    <span class="comment">// smart_ptr &amp;operator=(const smart_ptr &amp;) = delete;</span></span><br><span class="line">    <span class="comment">// // 但禁止拷贝不太方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 希望在拷贝时自动移动资源</span></span><br><span class="line">    <span class="built_in">smart_ptr</span>(smart_ptr &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    smart_ptr &amp;<span class="keyword">operator</span>=(smart_ptr &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 拷贝+交换的惯用法，实际上是移动+交换</span></span><br><span class="line">        <span class="comment">// 相当于先将rhs的资源转移给这个临时对象，再把这个临时对象的资源给this</span></span><br><span class="line">        <span class="built_in">smart_ptr</span>(rhs).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T *ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr &amp;rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在危险行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_addr</span><span class="params">(smart_ptr&lt;T&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Real address of shape is &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span> *&gt;(&amp;*ptr) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function">smart_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="built_in">print_addr</span>(ptr);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now address of shape is &quot;</span>&lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span> *&gt;(&amp;*ptr) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Real address of shape is <span class="number">0xe22130</span></span><br><span class="line">Now address of shape is <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>问题： <code>ptr</code> 变成了空指针，原因： <code>print_addr</code> 为值传递，调用函数 <code>smart_ptr(smart_ptr &amp;other)</code> ，将 <code>ptr</code> 传进函数内部对象并置空，离开作用域内部对象被销毁。</p>
<p>危险行为： <code>auto_ptr</code></p>
<p><strong>右值引用改进</strong>——&gt; <code>unique_ptr</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">smart_ptr</span>(smart_ptr &amp;&amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在进入赋值函数时，先构造一个新的rhs(根据构造函数功能进行构造，拷贝/移动)</span></span><br><span class="line">smart_ptr &amp;<span class="keyword">operator</span>=(smart_ptr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smart_ptr&lt;<span class="type">int</span>&gt; ptr1&#123;<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>)&#125;;</span><br><span class="line">smart_ptr&lt;<span class="type">int</span>&gt; ptr2&#123;ptr1&#125;;  <span class="comment">// 编译错误</span></span><br><span class="line">smart_ptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">ptr3=ptr1;					<span class="comment">//编译错误</span></span><br><span class="line">ptr3=<span class="built_in">move</span>(ptr1);</span><br><span class="line">smart_ptr&lt;<span class="type">int</span>&gt; ptr4&#123;<span class="built_in">move</span>(ptr3)&#125;;</span><br><span class="line"><span class="comment">// 无法引用 函数 &quot;smart_ptr&lt;T&gt;::smart_ptr(const smart_ptr&lt;int&gt; &amp;) [其中 T=int]&quot; (已隐式声明) -- 它是已删除的函数</span></span><br></pre></td></tr></table></figure>

<p><strong>完善行为：子类指针向基类转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类指针向基类转换</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt; &amp;&amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line">......<span class="comment">// 编译错误：invalid conversion from &#x27;A*&#x27; to &#x27;B*&#x27;</span></span><br><span class="line"><span class="function">smart_ptr&lt;A&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">smart_ptr&lt;B&gt; ptr2=<span class="built_in">move</span>(ptr1);</span><br><span class="line">......<span class="comment">// 编译成功：子类指针可以转换为基类指针</span></span><br><span class="line"><span class="function">smart_ptr&lt;B&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">smart_ptr&lt;A&gt; ptr2=<span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr实现"><a href="#unique-ptr实现" class="headerlink" title="unique_ptr实现"></a><code>unique_ptr</code>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">smart_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符，让行为更像指针</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    T *<span class="keyword">operator</span>&amp;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝，至少可以防止double delete的行为</span></span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    smart_ptr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> smart_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">smart_ptr</span>(smart_ptr &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在进入赋值函数时，先构造一个新的rhs(根据构造函数功能进行构造，拷贝/移动)</span></span><br><span class="line">    smart_ptr &amp;<span class="keyword">operator</span>=(smart_ptr rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类指针向基类转换</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt; &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T *ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr &amp;rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr实现"><a href="#shared-ptr实现" class="headerlink" title="shared_ptr实现"></a><code>shared_ptr</code>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (ptr)</span><br><span class="line">            shared_count_ = <span class="keyword">new</span> <span class="built_in">shared_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">smart_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果ptr不为空并且引用计数减1之后为空释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (ptr_ &amp;&amp; !shared_count_-&gt;<span class="built_in">reduce_count</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 特别：除了提供模板化的拷贝构造以外还要提供非模板的拷贝构造</span></span><br><span class="line">    <span class="comment">// 原因：C++不认为下面这种形式的拷贝构造为拷贝构造，所以会生成默认的拷贝构造函数（这种实现实际是错误的）</span></span><br><span class="line">    <span class="comment">// 所以：需要实现非模板的拷贝构造</span></span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_)</span><br><span class="line">        &#123;</span><br><span class="line">            other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">            shared_count_ = other.shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 但不需要提供移动构造函数，因为C++发现提供了拷贝构造函数，也不会默认生成移动构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带模板的拷贝构造：实现子类向基类的转换</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt; &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_)</span><br><span class="line">        &#123;</span><br><span class="line">            other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">            shared_count_ = other.shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带模板的移动构造</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt; &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr_ = other.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_)</span><br><span class="line">        &#123;</span><br><span class="line">            shared_count_ = other.shared_count_;</span><br><span class="line">            other.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    shared_count *shared_count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方便创建智能指针的工具函数"><a href="#方便创建智能指针的工具函数" class="headerlink" title="方便创建智能指针的工具函数"></a>方便创建智能指针的工具函数</h3><ul>
<li><p><code>make_unique</code></p>
<ul>
<li>语义明确，减少重复</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr_int = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象是结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> ptr_point = <span class="built_in">make_unique</span>&lt;Point&gt;(<span class="keyword">new</span> Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;); <span class="comment">// 有重复</span></span><br><span class="line"><span class="comment">// C++20</span></span><br><span class="line"><span class="keyword">auto</span> ptr_point = <span class="built_in">make_unique</span>&lt;Point&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>make_shared</code></p>
<ul>
<li>对象和引用计数一起只进行一次内存分配，提高性能</li>
</ul>
</li>
</ul>
<h3 id="其他智能指针特性"><a href="#其他智能指针特性" class="headerlink" title="其他智能指针特性"></a>其他智能指针特性</h3><ul>
<li>数组支持<ul>
<li><code>unique_ptr&lt;T[]&gt;</code>(C++11)</li>
<li><code>shared_ptr&lt;T[]&gt;</code>(C++17) &#x2F;&#x2F; C++17之前管理数组需要自定义删除器来释放内存，因为默认使用 <code>delete</code> 不能正确释放分配的数组，需要在自定义删除器中使用 <code>delete[]</code> 释放数组，C++17以后 <code>shared_ptr&lt;T[]&gt;</code> 默认使用 <code>delete[]</code> 来释放管理的对象</li>
</ul>
</li>
<li>自定义删除器<ul>
<li>定制智能指针离开作用域之后如何删除管理的对象</li>
<li>作用：在智能指针释放对象时进行一些特殊操作，比如打印日志、管理内存以外的其他资源比如说：文件句柄、数据库连接</li>
<li>使用：可以是函数&#x2F;类的对象&#x2F; <code>lambda</code>表达式</li>
</ul>
</li>
<li><code>weak_ptr</code><ul>
<li>循环引用问题：如果父节点管理子节点，使用 <code>shared_ptr</code> 指向子节点，此时子节点不可以用 <code>shared_ptr</code> 指向父节点，会形成环状依赖，引用计数不会降到0 。此时子节点可以使用 <code>weak_ptr</code> 指向父节点，这样可以保证引用计数最后会降为0，正常析构。</li>
<li>如果可以确定，子节点存在，父节点一定存在的话（不会出现指针悬空），可以考虑使用裸指针，性能更高，使用 <code>weak_ptr</code> 还是有引用计数增减的问题，性能还是有一点影响</li>
</ul>
</li>
</ul>
<h3 id="智能指针的使用建议"><a href="#智能指针的使用建议" class="headerlink" title="智能指针的使用建议"></a>智能指针的使用建议</h3><ol>
<li>在指针具有拥有权的时候应当使用 <code>unique_ptr</code> 和 <code>share_ptr</code></li>
<li>尽量使用 <code>unique_ptr</code>，一定需要引用计数才用 <code>share_ptr</code></li>
<li>注意对智能指针进行拷贝构造或者赋值会影响对象的生命周期（因为这些操作会改变与智能指针相关的引用计数），进而影响所管理对象的生命周期</li>
<li>传参一般仍使用普通指针或引用，除非要传递所有权</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/12/C-11-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/12/C-11-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">C++:移动语义和右值引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-12 15:46:44" itemprop="dateCreated datePublished" datetime="2024-08-12T15:46:44+08:00">2024-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-14 15:18:48" itemprop="dateModified" datetime="2024-08-14T15:18:48+08:00">2024-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="移动语义与右值引用"><a href="#移动语义与右值引用" class="headerlink" title="移动语义与右值引用"></a>移动语义与右值引用</h1><p><strong>1.值类别</strong></p>
<p><img src="/../assets/C-11-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/upload_515358ce5229d66d4d0b64078fff0085.jpg"></p>
<p>1）左值</p>
<ul>
<li>具名，可取地址</li>
<li>非常 <code>non-const</code>左值可以放在赋值运算符的左侧</li>
<li>常见情况<ul>
<li>变量</li>
<li>左值对象的成员</li>
<li>返回左值引用的表达式，如 <code>++x</code>、<code>x = 1</code></li>
<li>字符串字面量，如 <code>&quot;abc&quot;</code><ul>
<li>字符串字面值为左值一个最重要的原因是可以获取其地址，<code>cout &lt;&lt; &amp;&quot;abc&quot; &lt;&lt;endl;</code> 可以正常编译并运行。这是因为C++将字符串左值实现为 <code>char</code>型数组，为其分配了空间并且允许程序员对其进行操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2）纯右值</p>
<ul>
<li>不具名、不能取地址的“临时对象”</li>
<li>不可以放在赋值运算符的左侧</li>
<li>常见情况<ul>
<li>返回类型非引用的函数调用或运算符表达式，如 <code>x++</code>、 <code>1 + 2</code></li>
<li>除字符串字面量外的字面量，如 <code>true、 42</code></li>
<li><code>lambda</code>表达式</li>
</ul>
</li>
</ul>
<p>3）将亡值</p>
<ul>
<li>C++11引入，和纯右值合称为“右值”</li>
<li>不可以放在赋值运算符的左侧</li>
<li>常见情况<ul>
<li>右值对象或者数组的成员</li>
<li>返回右值引用的表达式，如 <code>move(x)——转换为右值引用 若x是int，则move(x)是int &amp;&amp;</code></li>
</ul>
</li>
</ul>
<p><strong>2.重要的成员函数重载</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝，当传入参数为左值时调用拷贝构造</span></span><br><span class="line">T::<span class="built_in">T</span>(<span class="type">const</span> T&amp; rhs);</span><br><span class="line">T&amp; T::<span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动，当传入参数为右值时调用移动构造</span></span><br><span class="line">T::<span class="built_in">T</span>(T&amp;&amp; rhs);</span><br><span class="line">T&amp; T::<span class="keyword">operator</span>=(T&amp;&amp; rhs);</span><br></pre></td></tr></table></figure>

<p><strong>3.移动的意义</strong></p>
<ul>
<li>允许资源的传递</li>
<li>允许返回大对象和容器<ul>
<li>一般同时使用异常来表示错误</li>
</ul>
</li>
</ul>
<p><strong>4.移动和 <code>noexcept</code></strong></p>
<p><code>noexcept</code>表示函数不会抛出异常</p>
<p>下列成员函数一般不允许抛出异常</p>
<ul>
<li>析构函数</li>
<li>移动构造函数，如果移动构造没有标成 <code>noexcept</code>，比如说 <code>vector</code>在动态调整大小的时候都不会调用移动构造在移动元素</li>
<li>移动赋值运算符</li>
<li>交换函数（<code>swap</code>）</li>
</ul>
<p><strong>5.五法则</strong></p>
<p>因为用户定义<strong>析构函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>的存在阻止<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>的隐式定义，所以任何想要移动语义的类应当声明全部<u>五个特殊成员函数</u>。</p>
<p><strong>6.右值引用的误用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Obj&amp;&amp; <span class="title">wrong_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Obj obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">move</span>(obj);<span class="comment">// 未定义的行为</span></span><br><span class="line">&#125;<span class="comment">// 返回栈上对象的指针或者引用永远都是错的，不管是左值还是右值</span></span><br><span class="line"></span><br><span class="line"><span class="function">Obj <span class="title">bad_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Obj obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">move</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果要返回函数内部即栈上的对象，直接return obj就行</span></span><br></pre></td></tr></table></figure>

<p><strong>7.坍缩规则和转发引用</strong></p>
<p>Q：<code>Vector(Vector&amp;&amp; rhs)</code>这里的 <code>rhs</code>是左值还是右值？</p>
<p>A：右值引用变量有标识符，所以是左值</p>
<p>——所以使用右值引用调用其他函数需要加上 <code>move()</code>保持右值属性</p>
<p>Q：在通用的函数模板里怎么办？</p>
<p>A：分别写两个不同的重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T &amp;&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">move</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：重复、啰嗦</p>
<p>引入<strong>转发引用</strong></p>
<ol>
<li><p><strong>坍缩规则</strong></p>
<p><code>T&amp; &amp; → T&amp;</code>、<code>T&amp; &amp;&amp; → T&amp;</code>、<code>T&amp;&amp; &amp; → T&amp;</code>、<code>T&amp;&amp; &amp;&amp; → T&amp;&amp;</code></p>
<p>所以只有 <code>T&amp;&amp; &amp;&amp;</code>会转化为右值引用</p>
</li>
<li><p>所以 <code>T&amp;&amp;</code>不是右值引用，当其出现在函数模板的参数或者变量声明中时 <code>T&amp;&amp;</code>是<strong>转发引用</strong></p>
</li>
<li><p><code>std::move(x)</code>：把x转换成右值引用</p>
</li>
<li><p><code>std::forward&lt;T&gt;(x)</code>：保持x的引用类型——传进来的T是左值，进函数的也是左值，右值也一样</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forward使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T&amp;&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(std:forward&lt;T&gt;(s));</span><br><span class="line">&#125;<span class="comment">// 不用写两个重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    circle temp;</span><br><span class="line">    <span class="built_in">bar</span>(temp);</span><br><span class="line">    <span class="built_in">bar</span>(<span class="built_in">circle</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8.临时对象的生命周期</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">result</span>;</span><br><span class="line"><span class="function">result <span class="title">process_shape</span><span class="params">(<span class="type">const</span> shape&amp;,<span class="type">const</span> shape&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">process_shape</span>(<span class="built_in">circle</span>(),<span class="built_in">triangle</span>());</span><br><span class="line"><span class="comment">// circle triangle result 对象在这条语句执行完成后销毁</span></span><br></pre></td></tr></table></figure>

<p>**生命期延长规则 **</p>
<ul>
<li><p>如果一个 <code>prvalue</code>(纯右值) 被绑定到一个引用上，它的生命周期会延长到跟这个引用变量一样长</p>
<p><code>result&amp;&amp; r=process_shape(circle(),triangle());</code></p>
<p>则右边这个临时对象的生命周期会延长到 <code>r</code> 离开作用域</p>
</li>
<li><p>如果是 <code>xvalue</code>(将亡值) ，则不能延长</p>
<p><code>result&amp;&amp; r=move(process_shape(circle(),triangle()));</code> 这种写法是错误的</p>
</li>
</ul>
<p> <strong>C++对象的自动生命周期</strong></p>
<ol>
<li>后创建的先析构</li>
<li>全局对象和静态对象在进入 <code>main</code> 之前创建</li>
<li>函数静态对象在第一次执行到声明语句时创建</li>
<li>函数自动对象在定义时创建，到定义的所在的 <code>&#125;</code> 即析构</li>
<li>临时对象在当前语句执行完成后即析构（除非赋值给引用变量而延长生命期）</li>
</ol>
<p>经典习题：析构顺序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa=<span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    B b;</span><br><span class="line">    <span class="type">static</span> D d;</span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">&#125;</span><br><span class="line">c pa b d </span><br><span class="line">~pa ~b ~d ~c</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/12/C-11-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/12/C-11-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" class="post-title-link" itemprop="url">C++:资源管理和对象的基本原则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-12 15:46:13" itemprop="dateCreated datePublished" datetime="2024-08-12T15:46:13+08:00">2024-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-14 15:18:53" itemprop="dateModified" datetime="2024-08-14T15:18:53+08:00">2024-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="资源管理和对象的基本原则"><a href="#资源管理和对象的基本原则" class="headerlink" title="资源管理和对象的基本原则"></a>资源管理和对象的基本原则</h2><h3 id="C-的特点与演化"><a href="#C-的特点与演化" class="headerlink" title="C++的特点与演化"></a>C++的特点与演化</h3><ol>
<li>为什么要使用C++？<ol>
<li>贴近硬件：<ul>
<li>使用原生的指令和类型，高性能</li>
<li>方便使用硬件（GPU、FPGA等）</li>
</ul>
</li>
<li>零开销抽象<ul>
<li>类、继承、模板</li>
<li>零开销！&#x3D;无开销， 零开销&#x3D;无额外开销</li>
</ul>
</li>
</ol>
</li>
<li>C和C++<ol>
<li>功能上，C++是C的超集</li>
<li>C++更加严格和安全，比如说const的正确性、指针的自动转换</li>
<li>现代C++的惯用法和C大相径庭<ul>
<li>C和机器码有更简单的映射关系，从C源码可以大致知道机器码是什么样</li>
<li>C++里有更多的抽象机制，源代码和机器码映射复杂得多</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="资源管理和对象的基本原则-1"><a href="#资源管理和对象的基本原则-1" class="headerlink" title="资源管理和对象的基本原则"></a>资源管理和对象的基本原则</h3><h4 id="1-堆与栈"><a href="#1-堆与栈" class="headerlink" title="1. 堆与栈"></a>1. 堆与栈</h4><p><strong>栈的示例</strong></p>
<p><img src="/../assets/C-11-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/upload_932af37df75786921fb0fae431eff972.png"></p>
<p><strong>main对应的x86汇编代码（msvc）</strong></p>
<p><img src="/../assets/C-11-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/upload_61fa7e6c8ee55bc1f67f56e1e1c8caae.png"></p>
<ol>
<li>设置栈框架：保存原有的ebp的值，设置新的ebp的值，ebp的作用：索引这个函数所用到的参数和本地变量</li>
<li>参数压栈</li>
<li>call：调用bar函数，名字奇怪的原因：编译器会起名</li>
<li>退栈：esp的指针+4——<code>pop eax</code>：取出数据，ESP指向栈中下一个元素</li>
<li>异或操作对eax寄存器清零，函数返回值存储在eax寄存器</li>
</ol>
<p><strong>bar对应的x86汇编代码（msvc）</strong></p>
<p><img src="/../assets/C-11-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/upload_2ef5d878a8166e38bd6c50b1ac20173b.png"></p>
<p>调用过程中的栈变化</p>
<p><img src="/../assets/C-11-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/upload_145f106f5096dd86530bee53d866b6f6.png"></p>
<p>“返回main的地址”：main下一句指令的地址</p>
<p><strong>栈内存的特性：</strong></p>
<ol>
<li>分配简单，只是移动栈指针</li>
<li>当前函数执行完即自动释放</li>
<li>后进先出，不可能出现内存碎片</li>
<li>函数返回后，栈上对象即被销毁</li>
<li>栈内存不分享，栈上对象通常没有多线程竞争问题（除非把指向栈内存的指针传递给另一个线程）</li>
</ol>
<p><strong>堆内存的特性：</strong></p>
<ol>
<li>分配和释放算法较为复杂</li>
<li>可能出现内存碎片</li>
<li><strong>内存的分配和释放通常需要加锁</strong></li>
<li>堆上的对象在被释放之前一直可以使用</li>
<li>堆上对象可能被多个线程访问，潜在有线程竞争问题</li>
</ol>
<h4 id="2-RAII"><a href="#2-RAII" class="headerlink" title="2. RAII"></a>2. RAII</h4><p>——析构函数和RAII是C++最基本的惯用法</p>
<ul>
<li><p><strong>RAII：</strong>Resource Acquisition Is Initialization</p>
</li>
<li><p>帮助管理堆上的对象：对象很大、对象的大小在编译时不能确定、对象是函数的返回值但由于特殊的原因不应使用对象的值返回</p>
</li>
<li><p><code>new</code>和<code>delete</code>的原理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new circle(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *temp=<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(circle));	<span class="comment">//分配内存</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        circle *ptr=<span class="built_in">static_cast</span>&lt;circle*&gt;(temp);	<span class="comment">//类型转换</span></span><br><span class="line">        ptr-&gt;<span class="built_in">circle</span>(...);						<span class="comment">//通过指针调用构造函数</span></span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delete ptr</span></span><br><span class="line"><span class="keyword">if</span>(ptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    ptr-&gt;~<span class="built_in">shape</span>();</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yhcs</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhcs</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
