<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yhcs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/21/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/" class="post-title-link" itemprop="url">算法：哈希函数和哈希表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-21 17:19:30" itemprop="dateCreated datePublished" datetime="2024-06-21T17:19:30+08:00">2024-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-24 23:44:46" itemprop="dateModified" datetime="2024-06-24T23:44:46+08:00">2024-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">算法学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="哈希函数和哈希表"><a href="#哈希函数和哈希表" class="headerlink" title="哈希函数和哈希表"></a>哈希函数和哈希表</h2><h3 id="哈希函数的特点"><a href="#哈希函数的特点" class="headerlink" title="哈希函数的特点"></a>哈希函数的特点</h3><ol>
<li><p>一般情况下，输入域无穷，输出域有限</p>
</li>
<li><p>相同的输入参数，一定会返回相同的值（内部不随机）</p>
</li>
<li><p>因为输出域可能小于输入域，所以不同输入可能有相同输出（def：哈希碰撞）</p>
</li>
<li><p>离散性：即便输入参数有一点点不一样，输出的值也有可能不一样</p>
<p>均匀性：假设输出域为S，很多个输入，映射到输出域，在输出域内任意选择一块区域，选中的输出点个数几乎一样</p>
<blockquote>
<p>假设输入：in1,in2,in3……</p>
<p>输出为：out1,out2,ou3……</p>
<p>如果输出为均匀的，那么将输出值%m之后，结果在0~m-1上也是均匀的</p>
</blockquote>
</li>
</ol>
<p><strong>例1：小内存返回大文件中出现次数最多的</strong></p>
<p>一个文件存放无符号整数，总共有40亿个，只有1G内存，返回出现次数最大的数</p>
<p>Q：使用简单的哈希，有可能出现内存不足</p>
<p>​		因为一条记录&lt;int,int&gt;至少占用8字节，则40亿数的哈希表至少占32G</p>
<p>解法：</p>
<p>40亿数—&gt;<strong>哈希函数</strong>—&gt;<strong>%100</strong>—&gt;0~99	（哈希函数的作用：使数据均匀分布）</p>
<p>相当于把一个40亿的大文件划分为100个小文件，由于哈希函数的均匀性，所以哈希值再取模以后一定是均匀分布在0~99</p>
<p>再依次读取小文件，建立每个小文件的哈希表，因为是均匀分布的，所以一个小文件的哈希表大小&#x3D;32G&#x2F;100</p>
<blockquote>
<p><strong>哈希碰撞的解决方案：</strong></p>
<ol>
<li><p>链表式解决</p>
</li>
<li><p>开放寻址法</p>
<ol>
<li><p>线性探测法：碰撞发生时，元素存储位置+1直到找到未占用位置</p>
<p>——&gt;问题：导致“二次聚集”：不同基地址的元素争夺同一个位置</p>
</li>
<li><p>平方探测法：为了避免上述问题，重新寻址时，位置+1，+4……+(冲突次数)^2</p>
</li>
</ol>
</li>
<li><p>再哈希法</p>
<p>遇到位置被占用，对该位置进行再次哈希，循环直到找到未占用的位置</p>
<p>注意：控制再哈希的次数阈值，不然可能出现无限循环的情况，导致查找元素时无法确定边界，即不知道进行几次哈希才算找不到元素</p>
</li>
</ol>
</blockquote>
<h3 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h3><p>先进行哈希，再模一个数确定放在哪个桶里</p>
<p>当单向链表过于长时，影响查找效率，对哈希表进行扩容——&gt;哈希表大小变为原来两倍，则单向链表长度变为原来一半（哈希函数的均匀性）</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><strong>问题：黑名单问题</strong></p>
<p>要求一个集合：增加和查询，不需要删除操作，且允许一定失误率（这种失误指的是把白误报成黑，不会出现把黑误报成白）——宁可错杀，不可放过</p>
<p>布隆过滤器：减少内存空间，但带来了一定的失误率</p>
<h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>——bit类型的数组	</p>
<p>实现方式：拿基础类型拼</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//4*8*10=320bits</span></span><br><span class="line"><span class="comment">//arr[0]——int[]0~31</span></span><br><span class="line"><span class="comment">//arr[1]——int[]32~63</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">178</span>;<span class="comment">//取得178bit的信息：0/1</span></span><br><span class="line"><span class="comment">//定位</span></span><br><span class="line"><span class="type">int</span> numIdx = i / <span class="number">32</span>;</span><br><span class="line"><span class="type">int</span> bitIdx = i % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得i位置的信息</span></span><br><span class="line"><span class="comment">//为什么是32，因为1个int是32bit</span></span><br><span class="line"><span class="type">int</span> status = ((arr[numIdx] &gt;&gt; bitIdx) &amp; <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> bit = (arr[i / <span class="number">32</span>] &gt;&gt; (i % <span class="number">32</span>)) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将状态改为1</span></span><br><span class="line">arr[numIdx] = arr[numIdx] | (<span class="number">1</span> &lt;&lt; bitIdx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将状态改为0</span></span><br><span class="line">arr[numIdx] = arr[numIdx] &amp; (~(<span class="number">1</span> &lt;&lt; bitIdx));</span><br></pre></td></tr></table></figure>

<h4 id="布隆过滤器的实现"><a href="#布隆过滤器的实现" class="headerlink" title="布隆过滤器的实现"></a>布隆过滤器的实现</h4><h5 id="（1）黑名单的建立"><a href="#（1）黑名单的建立" class="headerlink" title="（1）黑名单的建立"></a>（1）黑名单的建立</h5><p>准备一个大的位图长为m，k个哈希函数</p>
<p>url1—f1—&gt;m1	m1位置涂黑</p>
<p>​		—f2—&gt;m2	……	—fk—&gt;mk 	&#x3D;&#x3D;&#x3D;&gt;m1,m2,……mk位置涂黑</p>
<p>……	……	……</p>
<p>urln&#x3D;&#x3D;&#x3D;&gt;k个位置涂黑</p>
<p>ps：白的描黑，黑的别管</p>
<p>黑名单建立完毕</p>
<h5 id="（2）黑名单的查找"><a href="#（2）黑名单的查找" class="headerlink" title="（2）黑名单的查找"></a>（2）黑名单的查找</h5><p>比如说要查找urlx	&#x3D;&#x3D;&#x3D;》 经过k个哈希函数再%m得到k个位置</p>
<p>如果这k个位置都为黑，则输出urlx属于黑名单</p>
<blockquote>
<p>为什么黑不会报为白？只要urlx是黑的，则k个位置一定是黑的，报为黑名单</p>
<p>有可能白报为黑？例如m值很小，有可能位图全黑，误报率增加</p>
</blockquote>
<h5 id="（3）失误率的决定因素"><a href="#（3）失误率的决定因素" class="headerlink" title="（3）失误率的决定因素"></a>（3）失误率的决定因素</h5><ol>
<li><p>主要因素：m值</p>
<p>m太小，导致黑名单建立过程中都被涂黑了，失误率提高</p>
</li>
<li><p>第二个因素：k值</p>
<p>相当于一个样本采k个特征点，所以一定程度上，k值越大，误报率越低</p>
<p>但如果k值太大，同样会导致位图上涂黑的地方过多，提高误报率</p>
<p>所以，先选取合适的m值，再根据m值选取合适的k值来降低误报率</p>
</li>
</ol>
<h5 id="（4）布隆过滤器参数选择"><a href="#（4）布隆过滤器参数选择" class="headerlink" title="（4）布隆过滤器参数选择"></a>（4）布隆过滤器参数选择</h5><ol>
<li><p>确定模型：是不是类似于黑名单问题，只需要添加和查询，不需要删除操作</p>
</li>
<li><p>确定是否允许失误率</p>
</li>
<li><p>布隆过滤器的设计只跟两个因素有关：n&#x3D;样本量，p&#x3D;失误率</p>
<p>注意：跟单样本的大小没关系，因为放到布隆过滤器的值是哈希之后再模的，所以只需要保证单样本的大小属于哈希函数的输入范围</p>
<p>结果都向上取整<br>$$<br>m&#x3D;-\frac {n<em>\ln p} {(\ln 2)^2}\<br>k&#x3D;\ln 2</em>\frac {m}{n}\approx0.7*\frac {m}{n}<br>$$<br>上述取到的是理论值。</p>
<p>由实际的m，k值可得到实际的失误率p<br>$$<br>p&#x3D;(1-e^{-\frac {(n*k)}{m}})^k<br>$$</p>
</li>
</ol>
<h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>分布式服务器</p>
<p>假设有三台数据库服务器m1	m2	m3</p>
<p>data1——哈希	%3——m1		数据1放在m1里</p>
<p>…… 	……	……</p>
<p><strong>负载问题：</strong>如果有的数据高频，有的数据低频，导致服务器负载不均衡</p>
<h4 id="哈希key的选择"><a href="#哈希key的选择" class="headerlink" title="哈希key的选择"></a>哈希key的选择</h4><p>&#x3D;&#x3D;&#x3D;》题外话：哈希key的选择</p>
<p>​	可以：身份证、人名</p>
<p>​	不可以：国家名、性别</p>
<p>——》高频、中频、低频都有数量——》三台服务器负载均衡</p>
<p>例：以性别为哈希key会导致两台服务器在工作，另一台服务器负载为0</p>
<h4 id="一致性哈希-1"><a href="#一致性哈希-1" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p>下一个问题：</p>
<p>这种服务器选择方式——data&#x3D;&#x3D;》哈希&#x3D;&#x3D;》%服务器数量&#x3D;&#x3D;》数据存放位置</p>
<p>带来问题：当增加服务器或者减少服务器，数据迁移是全量的，也就是说所有数据都要重新计算哈希值再模运算</p>
<p>解决&#x3D;&#x3D;&#x3D;&#x3D;》一致性哈希</p>
<p>例：某种哈希算法得到的哈希值取值范围形成一个环0~x，数据得到的哈希值打在环上</p>
<p><strong>计算机器的哈希值</strong>：m1	m2	m3	m4</p>
<p><img src="/../assets/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%92%8C%E5%93%88%E5%B8%8C%E8%A1%A8/image-20240621170814015.png" alt="image-20240621170814015"></p>
<p>数据存储：数据&#x3D;&#x3D;哈希&#x3D;&#x3D;》data	——》插在环上，顺时针最近的就是数据存储的数据库，例如：data1放在m2上</p>
<p>所以在逻辑服务器上：m1 [c , 0]	m2 [0 , a]	m3 [a , b]	m4 [b , c]</p>
<p>所以在逻辑服务器上存储：0 a b c，插入数据data&#x3D;》计算哈希值datam&#x3D;》通过二分查找找到&gt;datam最左边的数&#x3D;&#x3D;》找到存储位置</p>
<ul>
<li>数据库增加，例如：增加m4，原来[b , 0]归m1管，现在分一部分[b , c]给m4管，所以只需要重新计算m1上的数据的哈希值</li>
<li>数据库减少，例如：减少m4，只需要把m4上的数据放到m1上就行</li>
</ul>
<p>&#x3D;&#x3D;&#x3D;》<strong>问题：</strong>当机器数量较少时，服务器分布是不均匀的也会导致负载不均衡的情况</p>
<h4 id="虚拟结点"><a href="#虚拟结点" class="headerlink" title="虚拟结点"></a>虚拟结点</h4><p>解决办法：<strong>虚拟结点</strong></p>
<p>m1：a1,a2……a1000</p>
<p>m2：b1,b2……b1000</p>
<p>m3：c1,c2……c1000</p>
<p>实际上去抢环的是虚拟结点，数量多&#x3D;&#x3D;》环上有3000个点&#x3D;&#x3D;》数据分布均衡</p>
<p>数据选择存放在哪个点——》存放在哪台服务器上</p>
<p>并且，这种方式还可以管理负载：比如，实际服务器a性能号，b性能差&#x3D;&#x3D;&#x3D;&gt;给a分配2000个虚拟结点，b分配500个虚拟结点</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/05/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/05/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">C++：多线程开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-05 12:06:32" itemprop="dateCreated datePublished" datetime="2024-06-05T12:06:32+08:00">2024-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-13 16:55:41" itemprop="dateModified" datetime="2024-07-13T16:55:41+08:00">2024-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="1-C-11-Thead线程库的基本使用"><a href="#1-C-11-Thead线程库的基本使用" class="headerlink" title="1. C++11 Thead线程库的基本使用"></a>1. C++11 Thead线程库的基本使用</h2><p><strong>进程与线程</strong></p>
<ul>
<li>进程：运行中的程序</li>
<li>线程：进程中的进程</li>
</ul>
<p>本文详细介绍C++11 Thead线程库的基本使用，包括如何创建线程、启动线程、等待线程完成以及如何分离线程等。</p>
<p><strong>1. 创建线程</strong></p>
<p>要创建线程，我们需要一个可调用的函数或函数对象，作为线程的入口点。在C++11中，我们可以使用函数指针、函数对象或lambda表达式来实现。创建线程的基本语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(function_name, args...)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>function_name</code>是线程入口点的函数或可调用对象</p>
<p><code>args...</code>是传递给函数的参数</p>
<p>测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	<span class="function">thread <span class="title">thread1</span><span class="params">(printHello)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<p><img src="/../assets/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/image-20240605121651420.png" alt="image-20240605121651420"></p>
<p>原因：还没等线程执行完就return了</p>
<hr>
<p><strong>2. 主程序等待线程执行完毕</strong></p>
<p>创建线程后，我们可以使用<code>t.join()</code>等待线程完成，或者使用<code>t.detach()</code>分离线程，让它在后台运行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>

<p>加上这一句，程序会检查线程是否执行结束，就不会报错了</p>
<hr>
<p><strong>3.传递参数</strong></p>
<p>我们可以使用多种方式向线程传递参数，例如使用函数参数、全局变量、引用等。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123; </span><br><span class="line">	++x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//值传递</span></span><br><span class="line">	<span class="function">thread <span class="title">thread1</span><span class="params">(printHello,<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">	thread1.<span class="built_in">join</span>();</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//引用传递</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(increment, ref(x))</span></span>;</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一个例子中，我们使用了一个字符串作为函数参数，传递给线程。在第二个例子中，我们使用了一个引用来传递一个整数变量。需要注意的是，当我们使用引用传递参数时，我们需要使用<code>std::ref</code>来包装引用，否则编译器会报错。</p>
<hr>
<p><strong>4.分离线程</strong></p>
<p><code>detach()</code>：用的不多，用这个即使线程没有执行完，主程序结束也不会报错</p>
<p>有时候我们可能不需要等待线程完成，而是希望它在后台运行。这时候我们可以使用<code>t.detach()</code>方法来分离线程。</p>
<p>需要注意的是，一旦线程被分离，就不能再使用<code>t.join()</code>方法等待它完成。而且，我们需要确保线程不会在主线程结束前退出，否则可能会导致未定义行为。</p>
<hr>
<p><strong>5. joinable()</strong></p>
<p>joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false。如果我们试图对一个不可加入的线程调用<code>join()</code>或<code>detach()</code>，则会抛出一个std::system_error异常。</p>
<p>所以严谨的做法，在使用join前面要使用joinable()进行判断</p>
<p>下面是一个使用joinable()方法的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-线程函数中的数据未定义错误"><a href="#2-线程函数中的数据未定义错误" class="headerlink" title="2. 线程函数中的数据未定义错误"></a>2. 线程函数中的数据未定义错误</h2><p><strong>1. 传递引用变量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123; </span><br><span class="line">	++x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">thread1</span><span class="params">(increment,<span class="number">1</span>)</span></span>;</span><br><span class="line">	thread1.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错：<img src="/../assets/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/image-20240605123357864.png" alt="image-20240605123357864"></p>
<p>因为函数参数是引用类型，所以使用<code>ref</code>来传递引用变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(increment,ref(a))</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 传递指针或引用指向局部变量的问题</strong></p>
<p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">thread thread1;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; x)</span></span>&#123; </span><br><span class="line">	++x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//a是局部变量</span></span><br><span class="line">	thread1 = <span class="built_in">thread</span>(increment, <span class="built_in">ref</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	thread1.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a是局部变量，这样会导致在线程函数执行时，指向局部变量<code>a</code>的指针已经被销毁，从而导致未定义行为。</p>
<hr>
<p><strong>3. 传递指针或引用指向已释放的内存的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *x)</span></span>&#123; </span><br><span class="line">	cout &lt;&lt; *x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">	thread thread1 = <span class="built_in">thread</span>(print, ptr);</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	thread1.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程还没有执行完，就把<code>ptr</code>释放了，会报错</p>
<p>将类对象传入函数，线程还没执行完就释放对象也会有同样的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(&amp;A::f, &amp;a)</span></span>;<span class="comment">//注意这个的写法</span></span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决：通过智能指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;A&gt; a = <span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(&amp;A::f, a)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4. 入口函数为类的私有成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//指向类A的一个指针</span></span><br><span class="line">	shared_ptr&lt;A&gt; a = <span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(&amp;A::f, a)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f()是类A的私有函数，不可访问</p>
<p>解决方法：使用友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">thread_f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//要使用类A的私有函数，需要在类A里生命声明它是友元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	shared_ptr&lt;A&gt; a = <span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">	<span class="function">thread <span class="title">t</span><span class="params">(&amp;A::f, a)</span></span>;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">thread_f</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-互斥量解决多数据共享的问题"><a href="#3-互斥量解决多数据共享的问题" class="headerlink" title="3. 互斥量解决多数据共享的问题"></a>3. 互斥量解决多数据共享的问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		a++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">thread1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">thread2</span><span class="params">(func)</span></span>;</span><br><span class="line">	thread1.<span class="built_in">join</span>();</span><br><span class="line">	thread2.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程同时对a进行操作，最后结果可能不等于20000，而是任何小于等于20000的可能值</p>
<p>解决方法：上锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;	</span><br><span class="line">		mtx.<span class="built_in">lock</span>();<span class="comment">//当访问a的时候对a进行加锁，其他线程无法访问a</span></span><br><span class="line">		a++;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();<span class="comment">//访问结束进行解锁，其他线程又可以访问a</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全：</strong>如果多线程程序每一次运行的结果和单线程程序的结果始终是一样的，那么这个线程就是安全的 </p>
<h2 id="4-互斥量死锁"><a href="#4-互斥量死锁" class="headerlink" title="4. 互斥量死锁"></a>4. 互斥量死锁</h2><p>假设有两个线程 T1 和 T2，它们需要对两个互斥量 mtx1 和 mtx2 进行访问，而且需要按照以下顺序获取互斥量的所有权：</p>
<ul>
<li><p>T1 先获取 mtx1 的所有权，再获取 mtx2 的所有权。</p>
</li>
<li><p>T2 先获取 mtx2 的所有权，再获取 mtx1 的所有权。</p>
</li>
</ul>
<p>如果两个线程同时执行，就会出现死锁问题。因为 T1 获取了 mtx1 的所有权，但是无法获取 mtx2 的所有权，而 T2 获取了 mtx2 的所有权，但是无法获取 mtx1 的所有权，两个线程互相等待对方释放互斥量，导致死锁。</p>
<p>测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex mtx1;</span><br><span class="line">mutex mtx2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		mtx1.<span class="built_in">lock</span>();</span><br><span class="line">		mtx2.<span class="built_in">lock</span>();</span><br><span class="line">		mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">		mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		mtx2.<span class="built_in">lock</span>();</span><br><span class="line">		mtx1.<span class="built_in">lock</span>();</span><br><span class="line">		mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">		mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">thread1</span><span class="params">(func1)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">thread2</span><span class="params">(func2)</span></span>;</span><br><span class="line">	thread1.<span class="built_in">join</span>();</span><br><span class="line">	thread2.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：程序卡死了</p>
<p>解决方法：改变死锁顺序，保证获取死锁的顺序是一样的，比如说都先获取mtx1，再获取mtx2，就不会卡住了</p>
<h2 id="5-lock-guard-与-unique-lock"><a href="#5-lock-guard-与-unique-lock" class="headerlink" title="5. lock_guard 与 unique_lock"></a>5. lock_guard 与 unique_lock</h2><hr>
<p><strong><code>lock_guard</code></strong></p>
<p><code>lock_guard</code> 是 C++ 标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。</p>
<p><code>lock_guard</code> 的特点如下：</p>
<ul>
<li>当构造函数被调用时，该互斥量会被自动锁定。</li>
<li>当析构函数被调用时，该互斥量会被自动解锁。</li>
<li><code>lock_guard</code> 对象不能复制或移动，因此它只能在局部作用域中使用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>;<span class="comment">//离开作用域的时候析构，自动解锁</span></span><br><span class="line">		a++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lock_guard</code> 的实现</p>
<ol>
<li><p>构造函数内进行加锁，析构函数内进行解锁</p>
</li>
<li><p>禁用了拷贝构造和赋值构造，所以不能复制和移动</p>
<p><img src="/../assets/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/image-20240605131332588.png" alt="image-20240605131332588"></p>
</li>
</ol>
<hr>
<p><strong><code>unique_lock</code></strong></p>
<p><code>unique_lock</code> 是 C++ 标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。</p>
<p><code>unique_lock</code> 提供了以下几个成员函数：</p>
<ul>
<li><code>lock()</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。</li>
<li><code>try_lock()</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数立即返回 <code>false</code>，否则返回 <code>true</code>。</li>
<li><code>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。</li>
<li><code>try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间点。</li>
<li><code>unlock()</code>：对互斥量进行解锁操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>;<span class="comment">//自动完成加锁</span></span><br><span class="line">============================================================</span><br><span class="line"><span class="comment">//延迟加锁，传入一个参数，此时解锁还是自动完成</span></span><br><span class="line">unique_lock&lt;mutex&gt; <span class="built_in">lg</span>(mtx,defer_lock);<span class="comment">//defer_lock</span></span><br><span class="line">lg.<span class="built_in">lock</span>();<span class="comment">//后面自己手动加速</span></span><br></pre></td></tr></table></figure>

<p>不自动加锁的原因：自己加锁可以有更多的加锁方案</p>
<p>比如：<code>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code>。其他互斥锁获取不到锁就阻塞在这里，而try_lock_for是只会等待一段时间，还没有获取锁就跳过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">timed_mutex mtx;<span class="comment">//mutex不支持对时间的操作，所以这里使用时间锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="function">unique_lock&lt;timed_mutex&gt; <span class="title">lg</span><span class="params">(mtx,defer_lock)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (lg.<span class="built_in">try_lock_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>))) &#123;</span><br><span class="line">			this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">			a++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">thread1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">thread2</span><span class="params">(func)</span></span>;</span><br><span class="line">	thread1.<span class="built_in">join</span>();</span><br><span class="line">	thread2.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：3</p>
<p>原因解释（一种可能情况）：</p>
<p>thread1先拿到锁（a++）,thread2等待1s；thread1释放锁，下一个又是thread1拿到锁（a++），则thread2等待2s就不等了，进入下一次循环拿到锁了，执行a++。所以结果：a&#x3D;3</p>
<h2 id="6-call-once及其使用场景"><a href="#6-call-once及其使用场景" class="headerlink" title="6. call_once及其使用场景"></a>6. call_once及其使用场景</h2><p>单例设计模式是一种常见的设计模式，用于确保某个类只能创建一个实例。由于单例实例是全局唯一的，因此在多线程环境中使用单例模式时，需要考虑线程安全的问题。</p>
<p>下面是一个简单的单例模式日志类的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Log</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Log</span>(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;</span><br><span class="line">	Log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> Log&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> Log* log = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (!log) log = <span class="keyword">new</span> <span class="built_in">Log</span>();</span><br><span class="line">		<span class="keyword">return</span> *log;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Log::<span class="built_in">GetInstance</span>().<span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个单例类中，我们使用了一个静态成员函数 <code>getInstance()</code> 来获取单例实例，该函数使用了一个静态局部变量 <code>log</code> 来存储单例实例。由于静态局部变量只会被初始化一次，因此该实现可以确保单例实例只会被创建一次。</p>
<p>但是，该实现并不是线程安全的。如果多个线程同时调用 <code>getInstance()</code> 函数，可能会导致多个对象被创建，从而违反了单例模式的要求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Log</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I am here&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Log</span>(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;</span><br><span class="line">	Log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> Log&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> Log* log = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//例如t1先进来log为空，创建完log之后，还没来得及把值赋给log</span></span><br><span class="line">        <span class="comment">//导致log已创建，但是log仍等于null</span></span><br><span class="line">        <span class="comment">//此时t2进来了，发现log为空又创建一次log</span></span><br><span class="line">        <span class="comment">//不符合单例模式的要求</span></span><br><span class="line">		<span class="keyword">if</span> (!log) log = <span class="keyword">new</span> <span class="built_in">Log</span>();</span><br><span class="line">		<span class="keyword">return</span> *log;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Log::<span class="built_in">GetInstance</span>().<span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(printError)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(printError)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<img src="/../assets/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/image-20240605135337140.png" alt="image-20240605135337140"></p>
<p>显然是有错误的</p>
<p>为了解决这些问题，我们可以使用 <code>std::call_once</code> 来实现一次性初始化，从而确保单例实例只会被创建一次。下面是一个使用 <code>std::call_once</code> 的单例实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> once_flag once;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Log</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;I am here&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> Log* log;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Log</span>(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;</span><br><span class="line">	Log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Log&amp; log) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!log) log = <span class="keyword">new</span> <span class="built_in">Log</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> Log&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">call_once</span>(once, init);</span><br><span class="line">		<span class="keyword">return</span> *log;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Log *Log::log = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Log::<span class="built_in">GetInstance</span>().<span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(printError)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(printError)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<img src="/../assets/C++_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/image-20240605135435435.png" alt="image-20240605135435435"></p>
<p>使用 <code>call_once</code> 可以确保单例实例只会被创建一次，从而避免了多个对象被创建的问题。</p>
<p><code>call_once</code> 是 C++11 标准库中的一个函数，用于确保某个函数只会被调用一次。其函数原型如下：</p>
<p>使用 <code>call_once</code> 可以在多线程环境中实现一次性初始化，避免了多个线程同时初始化的问题。例如，在单例模式中，可以使用 <code>call_once</code> 来保证单例实例只会被创建一次。</p>
<h2 id="7-condition-variable-与其使用场景"><a href="#7-condition-variable-与其使用场景" class="headerlink" title="7. condition_variable 与其使用场景"></a>7. condition_variable 与其使用场景</h2><p><strong><code>std::condition_variable</code> 的使用：</strong></p>
<ol>
<li><p>创建一个 <code>condition_variable</code> 对象。</p>
</li>
<li><p>创建一个互斥锁 <code>mutex</code> 对象，用来保护共享资源的访问。</p>
</li>
<li><p>在需要等待条件变量的地方</p>
<p>使用 <code>unique_lock&lt;mutex&gt;</code> 对象锁定互斥锁</p>
<p>并调用 <code>condition_variable::wait()</code>、<code>condition_variable::wait_for()</code> 或 <code>condition_variable::wait_until()</code> 函数等待条件变量。</p>
</li>
<li><p>在其他线程中需要通知等待的线程时，调用 <code>condition_variable::notify_one()</code> 或 <code>condition_variable::notify_all()</code> 函数通知等待的线程。</p>
</li>
</ol>
<p><strong>生产者消费者模型</strong></p>
<ul>
<li>任务队列</li>
<li>生产者：负责往任务队列加任务</li>
<li>消费者：负责往任务队列取任务</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="comment">//负责往队列加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		que.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//负责从队列里取任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> value = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：consumer取任务的同时，producer有可能正在放任务，所以要加速</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">condition_variable cv;<span class="comment">//条件变量</span></span><br><span class="line">mutex mtx;</span><br><span class="line"><span class="comment">//负责往队列加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">unique_lock&lt;mutex&gt;  <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">			que.<span class="built_in">push</span>(i);</span><br><span class="line">			<span class="comment">//通知消费者来取任务</span></span><br><span class="line">			cv.<span class="built_in">notify_one</span>();<span class="comment">//通知一个线程来取任务</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//负责从队列里取任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt;  <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		<span class="comment">//如果队列为空，就要等待</span></span><br><span class="line">		cv.<span class="built_in">wait</span>(lock, []() &#123;</span><br><span class="line">			<span class="keyword">return</span> !que.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);<span class="comment">//如果第二个参数为false，阻塞在这里</span></span><br><span class="line">		<span class="type">int</span> value = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Consumer : &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/04/C-TCP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/04/C-TCP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/" class="post-title-link" itemprop="url">C：TCP协议实现网络通讯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-04 22:37:54" itemprop="dateCreated datePublished" datetime="2024-06-04T22:37:54+08:00">2024-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-13 16:56:05" itemprop="dateModified" datetime="2024-07-13T16:56:05+08:00">2024-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>分成两个项目：<strong>服务端和客户端</strong>，完整源码在最后</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol>
<li><p>包含相关的库文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//windows网络通讯头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//一个库文件(windows不开源) ws2_32,提供接口</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启网络权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建socket套接字</p>
<p>先看一下socket的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socket(</span><br><span class="line">	_In_ <span class="type">int</span> af,		<span class="comment">//协议地址族 AF_INET/AF_INET6 ipv4/ipv6</span></span><br><span class="line">	_In_ <span class="type">int</span> type,		<span class="comment">//协议类型 TCP/UDP SOCK_STREAM/SOCK_DGRAM</span></span><br><span class="line">	_In_ <span class="type">int</span> protocol	<span class="comment">//保护方式</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>创建socket，如果创建失败，socket值为-1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket</span></span><br><span class="line">SOCKET server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//如果创建失败为-1</span></span><br><span class="line"><span class="comment">//进行检查</span></span><br><span class="line"><span class="keyword">if</span> (server_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;server socket create failed!Error Code:%d\n&quot;</span>, GetLastError());</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定ip和端口号</p>
<p>先来看一下<code>struct sockaddr_in</code>的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">	<span class="type">short</span>   sin_family;<span class="comment">//协议地址族</span></span><br><span class="line">	USHORT sin_port;<span class="comment">//端口号 5000+</span></span><br><span class="line">	IN_ADDR sin_addr;<span class="comment">//服务端，所有网卡都要监测，所以一般为0.0.0.0</span></span><br><span class="line">					<span class="comment">//inet_addr()——将点分十进制的IP地址转换为整数</span></span><br><span class="line">	CHAR sin_zero[<span class="number">8</span>];<span class="comment">//保留位置 可能将来升级协议可能会用</span></span><br><span class="line">&#125; SOCKADDR_IN, * PSOCKADDR_IN;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里涉及到<strong>大端序和小端序</strong>的内容</p>
<ul>
<li><p>大端序：数字大的在前面  比如：百 十 个</p>
</li>
<li><p>小端序：数字小的在前面  比如：个 十 百</p>
</li>
</ul>
<p>例：本地为<code>90 1f 00 00</code>为小端序，网络上为大端序<code>00 00 1f 90</code>（实际值）——8080</p>
<p><code>htons()</code>：小端序转换为大端序  eg：<code>htons(8080);</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local</span>;</span></span><br><span class="line">local.sin_family = AF_INET;</span><br><span class="line">local.sin_port = htons(<span class="number">8080</span>);<span class="comment">//将8080转换为大端序</span></span><br><span class="line">local.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定socket和端口</p>
<p><code>bind()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定socket和端口</span></span><br><span class="line"><span class="keyword">if</span> (bind(server_socket, (<span class="keyword">struct</span> sockaddr*)&amp;local, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))</span><br><span class="line">	== <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bind server socket failed!Error Code:%ld\n&quot;</span>, GetLastError());</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听端口</p>
<p><code>listen()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (listen(server_socket, <span class="number">10</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;listen server socket failed!Error Code:%ld\n&quot;</span>, GetLastError());</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind and listen success. wait client connect ...\n&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待客户端连接</p>
<p><code>accept()</code>：函数进行过程就是三次握手</p>
<p>accept函数是阻塞函数，没有客户端连接就停在这里</p>
<p><code>server_socket</code>：负责传话</p>
<p>返回值：一个新的socket负责通信  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKET client_socket = accept(server_socket, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环处理</p>
<p>可以接收消息或者发送消息，在循环内部自行定义</p>
<p><code>recv()</code>：从通信socket上接收数据</p>
<ul>
<li>返回值为-1，表示出错</li>
<li>返回值为0，表示正常断开</li>
<li>返回值为正数，表示接收到了多少数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="type">char</span> buff[BUFSIZ * <span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//接收数据</span></span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> ret = recv(client_socket, buff, BUFSIZ * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ret:%d buff:%s\n&quot;</span>, ret, buff);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">memcmp</span>(buff, <span class="string">&quot;music&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;music&quot;</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//表示当你接收到&quot;music&quot;，进行这部分处理</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;playing music\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li><p>包含相关的库文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//windows网络通讯头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//一个库文件(windows不开源) ws2_32,提供接口</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启网络权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建socket套接字</p>
<p>跟服务端代码一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket</span></span><br><span class="line">SOCKET client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;client socket create failed!Error Code:%d\n&quot;</span>, GetLastError());</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定目标ip和端口号</p>
<p>跟服务端不同的是，不是监听所有，只是针对目标ip</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">target</span>;</span></span><br><span class="line">target.sin_family = AF_INET;</span><br><span class="line">target.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">//127.0.0.1本地环回</span></span><br><span class="line"><span class="comment">//或者填本机ip</span></span><br><span class="line">target.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接连接就行</p>
<p><code>connect()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接连接就行</span></span><br><span class="line"><span class="keyword">if</span> (connect(client_socket, (<span class="keyword">struct</span> sockaddr*)&amp;target, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;connect server failed!Error Code:%ld\n&quot;</span>,GetLastError());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行通信</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="type">char</span> buff[BUFSIZ * <span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;please input send content:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buff);</span><br><span class="line">	<span class="type">int</span> ret = send(client_socket, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>最后同时运行两个项目就可以了！</p>
<h3 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">	<span class="comment">//创建socket</span></span><br><span class="line">	SOCKET server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//如果创建失败为-1</span></span><br><span class="line">	<span class="keyword">if</span> (server_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;server socket create failed!Error Code:%d\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//ip地址 + 端口号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local</span>;</span></span><br><span class="line">	local.sin_family = AF_INET;</span><br><span class="line">	local.sin_port = htons(<span class="number">8080</span>);<span class="comment">//将8080转换为大端序</span></span><br><span class="line">	local.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定socket和端口</span></span><br><span class="line">	<span class="keyword">if</span> (bind(server_socket, (<span class="keyword">struct</span> sockaddr*)&amp;local, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))</span><br><span class="line">		== <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind server socket failed!Error Code:%ld\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听这个端口</span></span><br><span class="line">	<span class="keyword">if</span> (listen(server_socket, <span class="number">10</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;listen server socket failed!Error Code:%ld\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bind and listen success. wait client connect ...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待客户端连接 accept函数在进行的过程中就是三次握手</span></span><br><span class="line">	SOCKET client_socket = accept(server_socket, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">char</span> buff[BUFSIZ * <span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="type">int</span> ret = recv(client_socket, buff, BUFSIZ * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ret:%d buff:%s\n&quot;</span>, ret, buff);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">memcmp</span>(buff, <span class="string">&quot;music&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;music&quot;</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;playing music\r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//开启网络权限</span></span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建socket</span></span><br><span class="line">	SOCKET client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;client socket create failed!Error Code:%d\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建目标IP和端口</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">target</span>;</span></span><br><span class="line">	target.sin_family = AF_INET;</span><br><span class="line">	target.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">	<span class="comment">//127.0.0.1本地环回</span></span><br><span class="line">	<span class="comment">//或者填本机ip</span></span><br><span class="line">	target.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接连接就行</span></span><br><span class="line">	<span class="keyword">if</span> (connect(client_socket, (<span class="keyword">struct</span> sockaddr*)&amp;target, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect server failed!Error Code:%ld\n&quot;</span>,GetLastError());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发消息</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">char</span> buff[BUFSIZ * <span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;please input send content:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buff);</span><br><span class="line">		<span class="type">int</span> ret = send(client_socket, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/C++_%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/10/C++_%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">C++：继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-10 15:29:26" itemprop="dateCreated datePublished" datetime="2024-05-10T15:29:26+08:00">2024-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-13 16:55:48" itemprop="dateModified" datetime="2024-07-13T16:55:48+08:00">2024-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><h4 id="1-继承的写法和权限问题"><a href="#1-继承的写法和权限问题" class="headerlink" title="1.继承的写法和权限问题"></a>1.继承的写法和权限问题</h4><p><code>class 子类：继承方法 父类</code></p>
<ol>
<li><p>继承方法：父类中的属性在子类中的最低权限</p>
<p>权限由低到高：<code>public</code> <code>protected</code> <code>private</code></p>
<p>eg:<code>class boy:public woman</code>——woman类的属性在boy类的最低权限为public</p>
</li>
<li><p>父类的私有属性对于子类来说是不可访问的</p>
</li>
</ol>
<blockquote>
<p>类的访问权限有三种：</p>
<ol>
<li>public 公共权限： 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问</li>
<li>protected 保护权限： 可以<strong>被该类中的函数、子类的函数、以及其友元函数</strong>访问,但不能被该类的对象访问</li>
<li>private 私有权限：只能由<strong>该类中的函数、其友元函数</strong>访问,不能被任何其他访问，该类的对象也不能访问。</li>
</ol>
<p>三种权限的区别：</p>
<p>public:可以被任意实体访问<br>protected:只允许本类及子类的成员函数访问<br>private:只允许本类的成员函数访问</p>
</blockquote>
<h4 id="2-继承中构造函数的写法"><a href="#2-继承中构造函数的写法" class="headerlink" title="2.继承中构造函数的写法"></a>2.继承中构造函数的写法</h4><p>子类的构造函数<strong>必须</strong>调用父类的构造函数</p>
<p>不想写的时候，习惯在父类中增加一个无参构造函数</p>
<p>如：直接<code>Boy boy；</code>——报错，显示是已删除的构造函数</p>
<p>​		解决方法：在woman类中新增无参构造函数<code>Woman()&#123;&#125;</code></p>
<p>测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Woman</span>(string name,<span class="type">int</span> age):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用基类带参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="comment">//初始化参数列表</span></span><br><span class="line">    <span class="built_in">Woman</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用基类无参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Woman &quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>:<span class="keyword">protected</span> Woman<span class="comment">//Woman类的属性在boy类的最低权限是protected</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Boy</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用子类无参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用初始化列表的方式调用父类的构造函数</span></span><br><span class="line">    <span class="built_in">Boy</span>(string name,<span class="type">int</span> age):<span class="built_in">Woman</span>(name,age)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用子类带参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Boy &quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//子类隐含有以下属性</span></span><br><span class="line">    <span class="comment">//void print();</span></span><br><span class="line">    <span class="comment">//string name;</span></span><br><span class="line">    <span class="comment">//int age;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Woman woman1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;============================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="function">Woman <span class="title">woman2</span><span class="params">(<span class="string">&quot;Amy&quot;</span>,<span class="number">40</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;============================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Boy boy1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;============================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="function">Boy <span class="title">boy2</span><span class="params">(<span class="string">&quot;Jack&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;============================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    woman2.<span class="built_in">print</span>();</span><br><span class="line">    boy2.<span class="built_in">print</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/image-20240510131814280.png" alt="image-20240510131814280"></p>
<p><strong>总结：子类构造函数一定会调用对应的父类构造函数</strong></p>
<h3 id="构造顺序和析构顺序"><a href="#构造顺序和析构顺序" class="headerlink" title="构造顺序和析构顺序"></a>构造顺序和析构顺序</h3><p>正常情况下，构造函数和析构函数顺序相反</p>
<p>测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;~A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;~B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;<span class="comment">//A</span></span><br><span class="line">    B b;<span class="comment">//AB</span></span><br><span class="line">    <span class="comment">//~B~A~A</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAB~B~A~A</span><br></pre></td></tr></table></figure>

<p>注意：有<code>delete</code>的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B *p=<span class="keyword">new</span> B;</span><br><span class="line">B b;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ABAB~B~A~B~A</span><br><span class="line"><span class="comment">//第一个~B~A是对象p的，什么delete就结束对象的生命周期</span></span><br><span class="line"><span class="comment">//b的析构是因为程序结束，生命周期结束自动调用析构函数    </span></span><br></pre></td></tr></table></figure>

<h3 id="类的继承的遗传性"><a href="#类的继承的遗传性" class="headerlink" title="类的继承的遗传性"></a>类的继承的遗传性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a):<span class="built_in">a</span>(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//int a;</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a),<span class="built_in">b</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//int a;</span></span><br><span class="line">    <span class="comment">//int b;</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">B</span>(a,b),<span class="built_in">c</span>(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>B继承A，C继承B——则C不仅包含B的属性，也包含A的属性</li>
<li>构造函数的写法：初始化参数列表—调用直接父类的构造函数+初始化其他属性</li>
</ol>
<h3 id="继承中的同名问题"><a href="#继承中的同名问题" class="headerlink" title="继承中的同名问题"></a>继承中的同名问题</h3><p>父类和子类同名问题：</p>
<ol>
<li>数据成员同名</li>
<li>成员函数同名</li>
</ol>
<p>通常情况为<strong>就近原则</strong>，优先调用本类的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Woman</span>(string name,<span class="type">int</span> age):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Woman &quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>:<span class="keyword">public</span> Woman</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="built_in">Boy</span>(string name,<span class="type">int</span> age,string mmName,<span class="type">int</span> mmAge):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age),<span class="built_in">Woman</span>(mmName,mmAge)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.通常都是就近原则，调用本类的</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Boy &quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//2.用类名限定，调用对应类的属性</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;类名限定 &quot;</span>&lt;&lt;Woman::name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; Woman::age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Boy <span class="title">coolboy</span><span class="params">(<span class="string">&quot;boy&quot;</span>,<span class="number">18</span>,<span class="string">&quot;woman&quot;</span>,<span class="number">40</span>)</span></span>;</span><br><span class="line">    coolboy.<span class="built_in">print</span>();<span class="comment">//Boy boy 18 类名限定 woman 40</span></span><br><span class="line">    coolboy.Woman.<span class="built_in">print</span>();<span class="comment">//Woman woman 40</span></span><br><span class="line">    Woman *p=<span class="keyword">new</span> <span class="built_in">Boy</span>(<span class="string">&quot;Woman_Boy&quot;</span>,<span class="number">19</span>,<span class="string">&quot;Woman&quot;</span>,<span class="number">41</span>);</span><br><span class="line">    p-&gt;<span class="built_in">print</span>();<span class="comment">//Woman WomanPtr 41</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boy boy 18</span><br><span class="line">类名限定 woman 40</span><br><span class="line">Woman woman 40</span><br><span class="line">Woman WomanPtr 41</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>通常情况下，都是就近原则，优先调用本类的数据和方法</p>
</li>
<li><p>如果加上类名限定，则调用对应类的数据和方法</p>
</li>
<li><p>如果是指针，没有<code>virtual</code>的情况下，也是就近原则</p>
</li>
<li><p>特殊情况：父类指针被子类对象初始化，没有<code>virtual</code>的情况看类型，有<code>virtual</code>的情况看对象</p>
<p><code>Woman *p=new Boy(&quot;Woman_Boy&quot;,19,&quot;Woman&quot;,41);p-&gt;print();</code></p>
<p>所以调用的<code>p</code>对应的类型<code>Woman</code>的函数</p>
<p>注意：不允许子类指针被父类对象初始化&#x2F;&#x2F;除非进行指针类型转换</p>
</li>
</ol>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><ol>
<li>多继承——存在两个及以上的父类</li>
<li>权限问题：跟单继承情况一样</li>
<li>构造函数写法：跟单继承也是一样的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Woman</span>(string WomanFName,string WomanSName):<span class="built_in">WomanFName</span>(WomanFName),<span class="built_in">WomanSName</span>(WomanSName)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string WomanFName;<span class="comment">//姓</span></span><br><span class="line">    string WomanSName;<span class="comment">//名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="built_in">Man</span>(string ManFName,string ManSName):<span class="built_in">ManFName</span>(ManFName),<span class="built_in">ManSName</span>(ManSName)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string ManFName;</span><br><span class="line">    string ManSName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Woman,<span class="keyword">public</span> Man</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//多继承要调用多个父类的构造函数</span></span><br><span class="line">    <span class="built_in">Son</span>(string ManFName,string ManSName,string WomanFName,string WomanSName,string SonSName)</span><br><span class="line">        :<span class="built_in">Man</span>(ManFName,ManSName),<span class="built_in">Woman</span>(WomanFName,WomanSName),<span class="built_in">SonFName</span>(ManFName+WomanFName),<span class="built_in">SonSName</span>(SonSName)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;mother:&quot;</span>&lt;&lt;WomanFName+WomanSName&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;father:&quot;</span>&lt;&lt;ManFName+ManSName&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son:&quot;</span>&lt;&lt;SonFName+SonSName&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string SonFName;</span><br><span class="line">    string SonSName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Son <span class="title">son</span><span class="params">(<span class="string">&quot;欧&quot;</span>,<span class="string">&quot;明明&quot;</span>,<span class="string">&quot;阳&quot;</span>,<span class="string">&quot;丽丽&quot;</span>,<span class="string">&quot;修&quot;</span>)</span></span>;</span><br><span class="line">    son.<span class="built_in">print</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mother:阳丽丽</span><br><span class="line">father:欧明明</span><br><span class="line">Son:欧阳修</span><br></pre></td></tr></table></figure>

<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>菱形继承：B、C继承A，D继承B、C</p>
<p>存在二义性：例如<code>A-int a;B-//int a;C-//int a;D-//int a;</code>二义性：D的a来自谁</p>
<p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/image-20240510145208543.png" alt="image-20240510145208543"></p>
<p>解决方法一：加上类型限定</p>
<p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-10%20145254.png" alt="屏幕截图 2024-05-10 145254"></p>
<p>解决方法二：使用虚继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : <span class="built_in">a</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a) : <span class="built_in">A</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> a) : <span class="built_in">A</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/image-20240510150049091.png" alt="image-20240510150049091"></p>
<p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/image-20240510150104291.png" alt="image-20240510150104291"></p>
<p>PS：几个类共享一份数据</p>
<p><img src="/../assets/C++_%E7%BB%A7%E6%89%BF/image-20240517090644926.png" alt="image-20240517090644926"></p>
<ul>
<li>类B和类C都虚继承自类A。虚继承意味着它们不会<strong>直接包含</strong>类A的实例，而是会包含一个指向类A的共享基类的指针（这通常被称为<strong>虚基类指针</strong>）。所以<code>sizeof(B)=8，sizeof(C)=8</code></li>
<li>类D继承了类B和类C，D需要包含B和C的所有成员，所以<code>sizeof(D)=16</code></li>
</ul>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数——用<code>virtual</code>修饰的函数</p>
<p>注意：构造函数不能为虚函数</p>
<h4 id="1-虚函数对类的内存的影响"><a href="#1-虚函数对类的内存的影响" class="headerlink" title="1.虚函数对类的内存的影响"></a>1.虚函数对类的内存的影响</h4><p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/image-20240510150956262.png" alt="image-20240510150956262"></p>
<h4 id="2-纯虚函数"><a href="#2-纯虚函数" class="headerlink" title="2.纯虚函数"></a>2.纯虚函数</h4><p>抽象类：具有纯虚函数的类</p>
<p>特性：不能创建对象，但可以创建对象类型指针</p>
<p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/image-20240510151251920.png" alt="image-20240510151251920"></p>
<p>子类继承抽象类，必须实现所有的纯虚函数才能实例化。</p>
<h4 id="3-虚析构函数"><a href="#3-虚析构函数" class="headerlink" title="3.虚析构函数"></a>3.虚析构函数</h4><p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/image-20240510151908866.png" alt="image-20240510151908866"></p>
<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父类构造函数</span><br><span class="line">子类构造函数</span><br><span class="line">父类析构函数</span><br><span class="line"><span class="comment">//发现没有调用子类的析构函数</span></span><br></pre></td></tr></table></figure>

<p>解决方法：使用虚析构函数</p>
<p>——注意：虚函数一旦被继承，不管被继承多少次，永远为虚函数</p>
<p><img src="/../assets/C-plus-plus-%E7%BB%A7%E6%89%BF/image-20240510152117958.png" alt="image-20240510152117958"></p>
<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父类构造函数</span><br><span class="line">子类构造函数</span><br><span class="line">子类析构函数</span><br><span class="line">父类析构函数</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/08/const%E5%92%8C-define%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/08/const%E5%92%8C-define%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">const和#define的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-08 22:03:36" itemprop="dateCreated datePublished" datetime="2024-05-08T22:03:36+08:00">2024-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-13 16:55:52" itemprop="dateModified" datetime="2024-07-13T16:55:52+08:00">2024-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-什么是const"><a href="#1-什么是const" class="headerlink" title="1.什么是const"></a>1.什么是const</h4><p><code>const</code>是C&#x2F;C++中的关键字，一般用来定义一个常量，所以<code>const</code>修饰的变量不能修改它的值</p>
<p><img src="/../assets/const%E5%92%8C-define%E7%9A%84%E5%8C%BA%E5%88%AB/image-20240508220803581.png" alt="image-20240508220803581"></p>
<h4 id="2-什么是-define"><a href="#2-什么是-define" class="headerlink" title="2.什么是#define"></a>2.什么是#define</h4><p><code>#define</code>是一条预编译指令，编译器在编译阶段会将所有使用到<code>#define</code>的地方进行替换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a 1</span></span><br><span class="line"><span class="comment">//编译前</span></span><br><span class="line"><span class="type">int</span> num=a;</span><br><span class="line"><span class="comment">//编译后进行替换，用1替换a</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h4 id="3-const和-define的区别"><a href="#3-const和-define的区别" class="headerlink" title="3.const和#define的区别"></a>3.const和#define的区别</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/08/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/08/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">next主题添加分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-08 21:42:34 / 修改时间：21:59:49" itemprop="dateCreated datePublished" datetime="2024-05-08T21:42:34+08:00">2024-05-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/" itemprop="url" rel="index"><span itemprop="name">博客维护</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-在主题里把分类选项打开"><a href="#1-在主题里把分类选项打开" class="headerlink" title="1.在主题里把分类选项打开"></a>1.在主题里把分类选项打开</h4><p>打开文件<code>\themes\next\_config.yml</code>,搜索<code>menu</code>，找到如下代码段</p>
<p><img src="/../assets/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/image-20240508214604038.png" alt="image-20240508214604038"></p>
<p>去掉<code>categories: /categories/ || fa fa-th</code>行的注释</p>
<h4 id="2-创建分类目录文件"><a href="#2-创建分类目录文件" class="headerlink" title="2.创建分类目录文件"></a>2.创建分类目录文件</h4><p>在博客文件夹下打开git bash，输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>成功后：<img src="/../assets/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/image-20240508214818388.png" alt="image-20240508214818388"></p>
<h4 id="3-打开生成的index-md文件"><a href="#3-打开生成的index-md文件" class="headerlink" title="3.打开生成的index.md文件"></a>3.打开生成的index.md文件</h4><p>打开后内容如下</p>
<p><img src="/../assets/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/image-20240508215002707.png" alt="image-20240508215002707"></p>
<p>加上 <code>type: &quot;categories&quot;</code></p>
<p><img src="/../assets/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/image-20240508215029274.png" alt="image-20240508215029274"></p>
<h4 id="4-给文章设置分类属性"><a href="#4-给文章设置分类属性" class="headerlink" title="4.给文章设置分类属性"></a>4.给文章设置分类属性</h4><p>添加以下内容就设置好分类了</p>
<p>注意：”-“跟类别名之间有一个<strong>空格</strong>！</p>
<p><img src="/../assets/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/image-20240508215850772.png" alt="image-20240508215850772"></p>
<p>如果需要二级分类：</p>
<p><img src="/../assets/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/image-20240508215842702.png" alt="image-20240508215842702"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统——文件系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-07 21:23:44 / 修改时间：21:27:09" itemprop="dateCreated datePublished" datetime="2024-05-07T21:23:44+08:00">2024-05-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件系统的组成"><a href="#文件系统的组成" class="headerlink" title="文件系统的组成"></a>文件系统的组成</h4><h5 id="文件系统的概念"><a href="#文件系统的概念" class="headerlink" title="文件系统的概念"></a>文件系统的概念</h5><ul>
<li><p>文件系统是操作系统中负责把用户的文件存到磁盘硬件中</p>
<ul>
<li>负责管理持久数据的子系统</li>
</ul>
</li>
<li><p>基本数据单位：文件</p>
<ul>
<li>目的：对磁盘上的文件进行组织管理</li>
</ul>
</li>
<li><p>“万物皆文件”</p>
<ul>
<li>普通的文件和目录、管道、块设备、socket都是统一由文件系统管理</li>
</ul>
</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul>
<li><p><strong>为每个文件分配两个数据结构</strong></p>
<ul>
<li><p><strong>索引节点inode</strong></p>
<ul>
<li><p>记录：文件的元信息</p>
<ul>
<li><p>inode编号、文件大小、访问权限、创建&#x2F;修改时间</p>
</li>
<li><p>数据在磁盘中的位置</p>
</li>
</ul>
</li>
<li><p>索引节点是文件的唯一标识</p>
<ul>
<li>跟文件一一对应<ul>
<li>同样存储在硬盘中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>目录项dentry</strong></p>
<ul>
<li><p>记录：文件的名字、索引节点指针、与其他目录项的层级关联关系</p>
<ul>
<li><p>不只是表示目录</p>
</li>
<li><p>也可以表示文件</p>
</li>
</ul>
</li>
<li><p>目录项是由内核维护的一个数据结构</p>
<ul>
<li>存放在内存中</li>
</ul>
</li>
<li><p>目录也是文件</p>
<ul>
<li><p>普通文件保存文件数据</p>
</li>
<li><p>目录文件保存子目录或者文件</p>
</li>
</ul>
</li>
<li><p>目录项vs目录</p>
<ul>
<li><p>区别</p>
<ul>
<li><p>目录是文件，存放在硬盘里</p>
</li>
<li><p>目录项是内核的一个数据结构，缓存在内存中</p>
</li>
</ul>
</li>
<li><p>关系</p>
<ul>
<li><p>查询目录频繁从磁盘读，效率低</p>
</li>
<li><p>内核把读过的目录用目录项这个数据结构缓存在内存中</p>
<ul>
<li>下次读到相同目录，直接从内存读</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>关系</strong></p>
<ul>
<li><p>目录项和索引节点是多对一的关系</p>
<ul>
<li>一个文件可以有多个别字</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li><p>索引节点存放在硬盘</p>
</li>
<li><p>目录项存放在内存</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>文件数据如何存储在磁盘</strong></p>
<ul>
<li><p>逻辑块&#x2F;数据块</p>
<ul>
<li><p>磁盘读写的最小单位是扇区(512B)，读写效率低</p>
</li>
<li><p>文件系统把多个扇区组成了一个数据块</p>
<ul>
<li><p>每次读写的最小单位就是逻辑块</p>
</li>
<li><p>linux中逻辑块大小为4KB(一次性读写8个扇区)</p>
<ul>
<li>提高读写效率</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>加速文件访问：把索引节点加载到内存</p>
<ul>
<li><p>磁盘格式化后的存储区域</p>
<ul>
<li><p>超级块</p>
<ul>
<li>存储文件系统的详细信息<ul>
<li>块个数、块大小、空闲块等</li>
</ul>
</li>
</ul>
</li>
<li><p>索引节点区</p>
<ul>
<li>存储索引节点</li>
</ul>
</li>
<li><p>数据块区</p>
<ul>
<li>存储文件或者目录数据</li>
</ul>
</li>
</ul>
</li>
<li><p>加载策略：只有需要的时候加载进内存</p>
<ul>
<li><p>超级块：文件系统挂载时加载进内存</p>
</li>
<li><p>索引节点区：当文件被访问时加载进内存</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h4><h4 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h4><h4 id="文件的存储"><a href="#文件的存储" class="headerlink" title="文件的存储"></a>文件的存储</h4><h4 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h4><h4 id="目录的存储"><a href="#目录的存储" class="headerlink" title="目录的存储"></a>目录的存储</h4><h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><h4 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I&#x2F;O"></a>文件I&#x2F;O</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/02/TME-0429%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/02/TME-0429%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">TME 0429面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-02 14:26:26" itemprop="dateCreated datePublished" datetime="2024-05-02T14:26:26+08:00">2024-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-07 21:39:52" itemprop="dateModified" datetime="2024-05-07T21:39:52+08:00">2024-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="腾讯音乐4-29-客户端开发面经"><a href="#腾讯音乐4-29-客户端开发面经" class="headerlink" title="腾讯音乐4.29 客户端开发面经"></a>腾讯音乐4.29 客户端开发面经</h3><h5 id="面试流程："><a href="#面试流程：" class="headerlink" title="面试流程："></a>面试流程：</h5><ol>
<li>面试官介绍部门情况</li>
<li>自我介绍（面试官要求介绍项目什么的）</li>
<li>问答环节</li>
</ol>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><h6 id="tcp建立连接是3次握手，断开连接是4次挥手，为什么会有这个差异？"><a href="#tcp建立连接是3次握手，断开连接是4次挥手，为什么会有这个差异？" class="headerlink" title="tcp建立连接是3次握手，断开连接是4次挥手，为什么会有这个差异？"></a>tcp建立连接是3次握手，断开连接是4次挥手，为什么会有这个差异？</h6><p>断开连接为什么要4次，而不是3次？</p>
<ul>
<li><strong>TCP连接为什么要三次握手</strong>？<ol>
<li>原因：<ol>
<li>客户端发出SYN，并收到ACK，这就是两次网络传输了。</li>
<li>同样服务器端也发出SYN，且等待对方回复，这也是两次网络传输。</li>
<li>加起来难道不是四次吗？实际上<strong>服务器端将对客户端 SYN(1) 的回复和自己 SYN(1) 的请求合并了</strong>，所以建立一个 TCP 连接最少只需要经过三次网络传输</li>
</ol>
</li>
<li>举例：已失效的连接请求报文</li>
</ol>
</li>
<li><strong>TCP断开连接为什么需要四次挥手？</strong><ol>
<li>原因：<ol>
<li>发起断开方发出FIN，并收到ACK，这就是两次网络传输了。</li>
<li>同样被断开方也发出FIN，且等待对方回复，这也是两次网络传输。</li>
<li>为什么服务端返回ACK的时候不一起发送FIN？因为在收到FIN时，服务端可能还有数据要发送，等到数据传输完时再发送FIN</li>
</ol>
</li>
</ol>
</li>
</ul>
<h6 id="ping命令使用过吗？traceroute跟它其实差不多，但是那个traceroute为什么能够探索到服务器的各个节点。"><a href="#ping命令使用过吗？traceroute跟它其实差不多，但是那个traceroute为什么能够探索到服务器的各个节点。" class="headerlink" title="ping命令使用过吗？traceroute跟它其实差不多，但是那个traceroute为什么能够探索到服务器的各个节点。"></a>ping命令使用过吗？traceroute跟它其实差不多，但是那个traceroute为什么能够探索到服务器的各个节点。</h6><blockquote>
<p><code>traceroute</code>是linux&#x2F;unix系统中用于分析本地到目标网络地址间的路由转发路径的工具，也常用于诊断网络链路不通或异常的发生位置。windows下命令为<code>tracert www.baidu.com</code></p>
</blockquote>
<p><img src="/../assets/TME-0429%E9%9D%A2%E7%BB%8F/image-20240502142938707-17150891457311.png" alt="image-20240502142938707"></p>
<blockquote>
<ol>
<li>每一跳的IP和时延信息是怎么得到的？</li>
<li>为什么每一跳有3个时延信息，有时还会显示2个或者3个IP地址？</li>
<li>为什么有些跳数显示的结果是请求超时？为什么有节点请求超时了还能到达后续的节点？</li>
</ol>
</blockquote>
<p><strong><code>traceroute/tracert</code>的原理</strong></p>
<ol>
<li>向目标IP发送3个TTL&#x3D;n（n起始值为1）的ICMP ping request报文，等待回应</li>
<li>如果收到<code>ICMP ping response</code>报文，则说明路由成功，通过n跳可以到达目标IP，traceroute工作完成。request和response的时间间隔就是时延，由于发送了3个request，因此有3个时延信息。</li>
<li>如果收到<code>ICMP TTL exceeded</code>报文，则说明第n跳路由到达了这个报文的发送节点。IP报文的TTL字段每经过一次路由转发就会减1，当减到0时当前的转发节点就会向报文的源IP发送一个ICMP TTL exceeded报文，因此发送了这个报文的节点就是第n跳的路由节点。由于发送了3个request，因此会返回3个报文和对应的时延信息。由于到目标IP的路由路径不一定是唯一的，因此报文在第n跳时到达的节点不一定是同一个，就有可能会输出多个第n跳节点地址。</li>
<li>如果在request发出3秒（默认超时时间）后仍然没有收到任何回应，则这轮<strong>检测超时</strong>。但这并<u>不意味着目标IP不可达</u>，而很可能是因为第n跳到达的节点<u>不允许发送TTL exceeded报文</u>。因此traceroute会继续后面的探测过程。</li>
<li>将TTL加1，回到第1步继续探测。</li>
</ol>
<h6 id="为什么https比http更安全？答：因为https在http的基础上使用了tls协议进行加密。"><a href="#为什么https比http更安全？答：因为https在http的基础上使用了tls协议进行加密。" class="headerlink" title="为什么https比http更安全？答：因为https在http的基础上使用了tls协议进行加密。"></a>为什么https比http更安全？答：因为https在http的基础上使用了tls协议进行加密。</h6><ul>
<li>讲一讲整个加密过程</li>
<li>所以密钥本身是对称加密的，还是那个非对称加密？</li>
</ul>
<h6 id="tcp三次握手成功以后，比方说给对方发1k的数据，对方会有什么下一步的动作？"><a href="#tcp三次握手成功以后，比方说给对方发1k的数据，对方会有什么下一步的动作？" class="headerlink" title="tcp三次握手成功以后，比方说给对方发1k的数据，对方会有什么下一步的动作？"></a>tcp三次握手成功以后，比方说给对方发1k的数据，对方会有什么下一步的动作？</h6><h6 id="tcp报文头多少字节-20-60B"><a href="#tcp报文头多少字节-20-60B" class="headerlink" title="tcp报文头多少字节 20~60B"></a>tcp报文头多少字节 20~60B</h6><blockquote>
<p>udp报文头部为8B</p>
</blockquote>
<h6 id="stl的vector是线程安全的吗？"><a href="#stl的vector是线程安全的吗？" class="headerlink" title="stl的vector是线程安全的吗？"></a>stl的vector是线程安全的吗？</h6><p>是，所有操作加了同步锁，不支持多线程操作</p>
<blockquote>
<p>vector特点：</p>
<p>1.动态分配空间，当空间不足时，会执行分配新空间——复制元素——释放原空间；</p>
<p>2.在末端插入和删除执行效率高，在其他位置插入和删除效率低(为保持原有相对次序，插入和删除点之后的元素需要整体后移)；</p>
<p>3.删除数据并不会释放已分配的空间，因此vector的capacity(容量)大于vector的size(元素个数);</p>
<p>4.支持随机访问，且执行效率高；</p>
<p>5.vector是线程安全的，所有操作加了同步锁，不支持多线程操作</p>
<p>#vector跟数组的差别</p>
<p>区别<br>1.大小固定 vs 大小可变：</p>
<p>数组是一个具有<strong>固定大小</strong>的连续内存块，一旦定义后，其大小无法改变。<br>vector是一个<strong>动态数组</strong>，它使用了自动扩容机制，可以根据需要动态调整大小。可以通过添加或删除元素来改变vector的大小。<br>2.初始化：</p>
<p>数组的<strong>大小在定义时必须确定</strong>，并且可以使用初始化列表或循环初始化等方式进行初始化。<br>vector的大小可以在定义时指定，也可以在后续使用push_back()、emplace_back()等函数插入元素进行初始化。<br>3.访问元素：</p>
<p>数组通过索引直接访问元素，可以使用下标运算符[]或指针运算符*来访问特定位置的元素。<br>vector也可以使用下标运算符[]访问元素，还可以使用at()函数进行边界检查。<br>4.自动内存管理：</p>
<p>数组需要<strong>手动管理内存</strong>，包括分配和释放内存。<br>vector自动处理内存管理，会自动增加或减少内存以适应元素的数量。<br>5.功能差异：</p>
<p>vector提供了许多方便的成员函数，如push_back()、pop_back()、insert()、erase()等，用于在尾部或指定位置添加、删除元素。<br>数组本身没有提供这些功能，需要手动编写代码来实现。</p>
</blockquote>
<h6 id="map底层的红黑树的实现原理"><a href="#map底层的红黑树的实现原理" class="headerlink" title="map底层的红黑树的实现原理"></a>map底层的红黑树的实现原理</h6><h6 id="C-虚函数跟普通的函数有什么区别吗？"><a href="#C-虚函数跟普通的函数有什么区别吗？" class="headerlink" title="C++虚函数跟普通的函数有什么区别吗？"></a>C++虚函数跟普通的函数有什么区别吗？</h6><h6 id="虚函数表是在什么阶段，可以知道它自己的指针是多少。"><a href="#虚函数表是在什么阶段，可以知道它自己的指针是多少。" class="headerlink" title="虚函数表是在什么阶段，可以知道它自己的指针是多少。"></a>虚函数表是在什么阶段，可以知道它自己的指针是多少。</h6><h6 id="utf16，包括utf32，讲一下他们的差异。"><a href="#utf16，包括utf32，讲一下他们的差异。" class="headerlink" title="utf16，包括utf32，讲一下他们的差异。"></a>utf16，包括utf32，讲一下他们的差异。</h6><ul>
<li><p><strong>utf8</strong></p>
<ol>
<li><p>特点：使用<strong>变长字节数</strong></p>
<p>原因：可以理解为按需分配，节省存储空间</p>
<p>优势：节省空间；劣势：不利于程序内部处理</p>
<blockquote>
<p>而UTF-32这样<strong>等长码元序列</strong>(即等宽码元序列)的编码方式就比较适合程序处理，当然，缺点是比较耗费存储空间</p>
</blockquote>
</li>
<li><p>编码方式：最短为一个字节，通过utf8首字节就能判断编码有几个字节</p>
<ol>
<li>如果首字节以0开头，肯定是单字节编码(即单个单字节码元)；</li>
<li>如果首字节以110开头，肯定是双字节编码(即由两个单字节码元所组成的双码元序列)；</li>
<li>如果首字节以1110开头，肯定是三字节编码(即由三个单字节码元所组成的三码元序列)，以此类推。</li>
</ol>
<ul>
<li><p>这里的0相当于终结标志</p>
</li>
<li><p>前缀码的作用：区分和标识</p>
</li>
<li><p>除了单字节编码外，由多个单字节码元所组成的多字节编码其首字节以外的后续字节均以10开头(以区别于单字节编码以及多字节编码的首字节)。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>utf16</strong></p>
<ol>
<li><p>特点：2字节或者4字节（<strong>没有办法兼容ASCII编码</strong>，ASCII编码使用1 Byte来进行存储）</p>
</li>
<li><p>字节顺序问题：如某字符为十六进制编码<code>4E59</code>，按两个字节拆分为<code>4E</code>和<code>59</code></p>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="left">读取顺序</th>
<th align="left">显示字符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Windows</td>
<td align="left">4E 59</td>
<td align="left">奎</td>
</tr>
<tr>
<td align="left">Mac</td>
<td align="left">59 4E</td>
<td align="left">乙</td>
</tr>
</tbody></table>
<p>引入：字节顺序标记<strong>（英语：byte-order mark，BOM）</strong>来标记是大端序还是小端序。</p>
</li>
<li><p>BOM：是一个有特殊含义的统一码字符，码点为<code>U+FEFF</code>。当以UTF-16或UTF-32来将UCS&#x2F;统一码字符所组成的字符串编码时，这个字符被用来标示其字节序。</p>
<p><strong>字符<code>U+FEFF</code>如果出现在字节流的开头，则用来标识该字节流的字节序，是高位在前还是低位在前。</strong></p>
</li>
</ol>
</li>
</ul>
<h6 id="空的class大小是多少？"><a href="#空的class大小是多少？" class="headerlink" title="空的class大小是多少？"></a>空的class大小是多少？</h6><ol>
<li>空类大小&#x3D;1，因为编译器需要安插进去一个 <code>char</code>，使得这个 class 对象得以在内存中被配置独一无二的地址。</li>
<li>某个类A继承该空类<ol>
<li>如果A为空，<code>sizeof(A)=1</code></li>
<li>如果A不为空，<code>sizeof(A)=真实大小</code></li>
</ol>
</li>
<li>如果一个类没有成员变量，但是含虚函数&#x2F;虚继承别的类，则会生成一个<code>vptr</code>，<code>sizeof(A)=4/8</code></li>
</ol>
<blockquote>
<p><strong>虚继承</strong></p>
<ol>
<li><p>多继承：多个直接基类中产生派生类，存在问题：多个基类相互交织</p>
<p><img src="/../assets/TME-0429%E9%9D%A2%E7%BB%8F/image-20240505011615000-17150891823763.png" alt="image-20240505011615000"></p>
<p>假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A –&gt;B–&gt;D 这条路径，还是来自 A–&gt;C–&gt;D 这条路径。</p>
</li>
<li><p>虚继承：为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p>
<p>目的：让某个类做出声明，承诺愿意共享它的基类。</p>
<p><img src="/../assets/TME-0429%E9%9D%A2%E7%BB%8F/image-20240505011755261-17150891900515.png" alt="image-20240505011755261"></p>
<p>本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>计算类的大小，还要考虑字节对齐</p>
</blockquote>
<h6 id="定义一个结构体，里面可能有很多的数据类型。在不同的编译器，不同的系统下，结构体大小可能会有不同的大小。你觉得是因为什么？（字节对齐）"><a href="#定义一个结构体，里面可能有很多的数据类型。在不同的编译器，不同的系统下，结构体大小可能会有不同的大小。你觉得是因为什么？（字节对齐）" class="headerlink" title="定义一个结构体，里面可能有很多的数据类型。在不同的编译器，不同的系统下，结构体大小可能会有不同的大小。你觉得是因为什么？（字节对齐）"></a>定义一个结构体，里面可能有很多的数据类型。在不同的编译器，不同的系统下，结构体大小可能会有不同的大小。你觉得是因为什么？（字节对齐）</h6><ol>
<li>内存对齐（Padding）：<br>为了提高数据访问的效率，许多处理器和编译器会要求数据按照特定的边界对齐，不同的编译器可能会有不同的默认对齐设置或对齐策略。例如，某些处理器可能要求一个<code>int</code>类型的变量在4字节边界上对齐。如果结构体中的某个成员不满足这个对齐要求，编译器会在成员之间插入额外的空间（填充字节），以达到所需的对齐。这会导致结构体的大小在不同系统或编译器下有所不同。</li>
<li>数据类型的大小：<br>虽然标准数据类型（如<code>int</code>、<code>long</code>等）在大多数系统上都有固定的大小，但在某些系统或编译器下，它们的大小可能会有所不同。</li>
</ol>
<h6 id="C-的加锁方式"><a href="#C-的加锁方式" class="headerlink" title="C++的加锁方式"></a>C++的加锁方式</h6><h6 id="C-子类跟基类的构造顺序和析构顺序，为什么？"><a href="#C-子类跟基类的构造顺序和析构顺序，为什么？" class="headerlink" title="C++子类跟基类的构造顺序和析构顺序，为什么？"></a>C++子类跟基类的构造顺序和析构顺序，为什么？</h6><h6 id="局部变量在进程内存的哪一块里面"><a href="#局部变量在进程内存的哪一块里面" class="headerlink" title="局部变量在进程内存的哪一块里面"></a>局部变量在进程内存的哪一块里面</h6><p>一般全局变量存放在数据区，局部变量存放在栈区，<br>动态变量存放在堆区，函数代码放在代码区。</p>
<h6 id="函数的参数的压栈顺序：参数从右到左入栈"><a href="#函数的参数的压栈顺序：参数从右到左入栈" class="headerlink" title="函数的参数的压栈顺序：参数从右到左入栈"></a>函数的参数的压栈顺序：参数从右到左入栈</h6><p>例：<code>void func(int a,int b,int c)</code>，进栈顺序为：<code>c b a</code>.</p>
<h6 id="网络的多路复用？"><a href="#网络的多路复用？" class="headerlink" title="网络的多路复用？"></a>网络的多路复用？</h6><h6 id="线程切换怎么保证切回来的时候，还能够按照原来流程继续走下去。"><a href="#线程切换怎么保证切回来的时候，还能够按照原来流程继续走下去。" class="headerlink" title="线程切换怎么保证切回来的时候，还能够按照原来流程继续走下去。"></a>线程切换怎么保证切回来的时候，还能够按照原来流程继续走下去。</h6><h6 id="算法问题：运营在线上搞了两个活动，回收数据的时候，a活动收了2千万的那个qq号，b活动他回收了那个5千万的qq号。求两个活动大概都参加的用户有多少。设计一个算法求a和b的交集。"><a href="#算法问题：运营在线上搞了两个活动，回收数据的时候，a活动收了2千万的那个qq号，b活动他回收了那个5千万的qq号。求两个活动大概都参加的用户有多少。设计一个算法求a和b的交集。" class="headerlink" title="算法问题：运营在线上搞了两个活动，回收数据的时候，a活动收了2千万的那个qq号，b活动他回收了那个5千万的qq号。求两个活动大概都参加的用户有多少。设计一个算法求a和b的交集。"></a>算法问题：运营在线上搞了两个活动，回收数据的时候，a活动收了2千万的那个qq号，b活动他回收了那个5千万的qq号。求两个活动大概都参加的用户有多少。设计一个算法求a和b的交集。</h6><h6 id="如果编写组件，提供接口定义入参和出参，为什么入参尽可能使用C的数据类型，而不是使用C"><a href="#如果编写组件，提供接口定义入参和出参，为什么入参尽可能使用C的数据类型，而不是使用C" class="headerlink" title="如果编写组件，提供接口定义入参和出参，为什么入参尽可能使用C的数据类型，而不是使用C++"></a>如果编写组件，提供接口定义入参和出参，为什么入参尽可能使用C的数据类型，而不是使用C++</h6><h6 id="共享屏幕做算法：解析http报文，实现传入参数key返回value"><a href="#共享屏幕做算法：解析http报文，实现传入参数key返回value" class="headerlink" title="共享屏幕做算法：解析http报文，实现传入参数key返回value"></a>共享屏幕做算法：解析http报文，实现传入参数key返回value</h6><h6 id="共享屏幕做算法：快排"><a href="#共享屏幕做算法：快排" class="headerlink" title="共享屏幕做算法：快排"></a>共享屏幕做算法：快排</h6>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/30/Linux_Linux%E5%86%85%E6%A0%B8%E7%BA%A7%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80(1)Linux%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/30/Linux_Linux%E5%86%85%E6%A0%B8%E7%BA%A7%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80(1)Linux%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Linux：Linux内核级安全开发基础(1)Linux的动态内核模块机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-30 00:29:28" itemprop="dateCreated datePublished" datetime="2024-04-30T00:29:28+08:00">2024-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-04 23:04:41" itemprop="dateModified" datetime="2024-07-04T23:04:41+08:00">2024-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Linux内核级安全开发基础"><a href="#Linux内核级安全开发基础" class="headerlink" title="Linux内核级安全开发基础"></a>Linux内核级安全开发基础</h3><h4 id="1-1-Linux的动态内核模块机制"><a href="#1-1-Linux的动态内核模块机制" class="headerlink" title="1.1 Linux的动态内核模块机制"></a>1.1 Linux的动态内核模块机制</h4><h5 id="1-动态内核模块机制概述"><a href="#1-动态内核模块机制概述" class="headerlink" title="1.动态内核模块机制概述"></a><strong>1.动态内核模块机制概述</strong></h5><p>Linux内核：宏内核</p>
<p>缺点：系统功能扩展性差，设计之初实现了较多冗余功能，影响操作系统的运行效率和系统稳定性</p>
<p>解决办法：引入<strong>内核模块动态加载机制</strong>——通过内核模块的扩展和动态加载实现操作系统功能的扩充，当一些内核模块不再使用时可以卸载该模块，以保证操作系统的运行效率和系统稳定性。</p>
<blockquote>
<p>Linux内核&#x3D;基本内核+一系列内核模块</p>
</blockquote>
<p>​		系统启动——加载基本内核——用户按照需要动态加载系统内核模块——不需要时再从内核卸载</p>
<p>​		<strong>好处：</strong>a.让内核保持很小的尺寸，同时又非常灵活；b.可以不通过重构内核并频繁重启的方式来尝试运行新内核代码，便于新设备驱动程序的编写和调试</p>
<h5 id="2-linux内核模块的加载和卸载"><a href="#2-linux内核模块的加载和卸载" class="headerlink" title="2.linux内核模块的加载和卸载"></a><strong>2.linux内核模块的加载和卸载</strong></h5><p><strong>内核模块的加载方式</strong>有两种：</p>
<ul>
<li>使用<code>insmod</code>命令手工加载模块</li>
<li>在需要时加载模块，即请求加载</li>
</ul>
<p><strong>符号表：</strong>所有能够被内核模块使用的资源（基本内核中定义的资源和新加载模块中定义的资源），被操作系统以内核输出符号表的形式统一管理。</p>
<p><strong>内核模块加载过程：</strong></p>
<ol>
<li>在内核输出符号表中找到本模块用到的外部符号<ol>
<li>找不到定义的外部符号，或者找到外部符号但是与所定义的类型不一致，系统拒绝加载该模块</li>
</ol>
</li>
<li>加载成功——&gt;将本模块输出的符号添加到内核输出符号表中</li>
</ol>
<blockquote>
<p>模块A输出的符号被模块B使用，则称模块B依赖于模块A，或者模块A被模块B引用</p>
</blockquote>
<p><strong>引用计数：</strong>新模块加载到内核过程中，内核会检查该模块使用的外部符号，增加这些外部符号所在模块的引用技术。可通过<code>lsmod</code>命令查看系统已加载的内核模块以及模块的引用计数。</p>
<p><img src="/../assets/%E4%B8%80%E3%80%81Linux%E5%86%85%E6%A0%B8%E7%BA%A7%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/image-20240430002656528.png" alt="image-20240430002656528"></p>
<p><strong>内核模块的卸载：</strong>通过使用<code>rmmod</code>命令来卸载</p>
<ul>
<li>如果要卸载的内核模块正在被其他模块引用，即引用计数不为零，linux系统会拒绝卸载该模块</li>
<li>一旦内核模块被成功卸载<ul>
<li>linux从内核符号输出表中删除在该模块中定义的外部符号</li>
<li>检查模块曾引用的外部符号所在的模块，引用计数减1</li>
</ul>
</li>
</ul>
<p>内核模块除了可以手动卸载以外，还支持自动卸载——内核模块的自动卸载工作由后台进程<code>kerneld</code>完成，<code>keneld</code>在相应定时器到期时检查，卸载不用的模块</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/27/How-to-build-a-personal-blog-on-GitHub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhcs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/27/How-to-build-a-personal-blog-on-GitHub/" class="post-title-link" itemprop="url">使用GitHub搭建个人博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-27 19:50:22" itemprop="dateCreated datePublished" datetime="2024-04-27T19:50:22+08:00">2024-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-10 15:26:05" itemprop="dateModified" datetime="2024-05-10T15:26:05+08:00">2024-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/" itemprop="url" rel="index"><span itemprop="name">博客维护</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="使用GitHub搭建个人博客"><a href="#使用GitHub搭建个人博客" class="headerlink" title="使用GitHub搭建个人博客"></a>使用GitHub搭建个人博客</h3><h4 id="1-安装nodejs"><a href="#1-安装nodejs" class="headerlink" title="1.安装nodejs"></a>1.安装nodejs</h4><p>下载地址：<a target="_blank" rel="noopener" href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p>
<ul>
<li>选择合适的包下载安装</li>
</ul>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240426220019530.png" alt="image-20240426220019530"></p>
<ul>
<li><p>验证是否下载成功</p>
<p>在git bash里面执行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240426220150706.png" alt="image-20240426220150706"></p>
</li>
</ul>
<h4 id="2-安装cnpm"><a href="#2-安装cnpm" class="headerlink" title="2.安装cnpm"></a>2.安装cnpm</h4><ul>
<li><p>在git bash里面执行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=http://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p>检查是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240426220719751.png" alt="image-20240426220719751"></p>
<h4 id="3-安装hexo和初始化博客"><a href="#3-安装hexo和初始化博客" class="headerlink" title="3.安装hexo和初始化博客"></a>3.安装hexo和初始化博客</h4><h5 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="(1)安装hexo"></a>(1)安装hexo</h5><p>在git bash里面执行下面的命令安装hexo</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h5 id="2-初始化博客"><a href="#2-初始化博客" class="headerlink" title="(2)初始化博客"></a>(2)初始化博客</h5><p>新建或者选择一个文件夹，作为blog文件夹，在该文件夹下打开git bash</p>
<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>如果跟我一样遇到问题，可以更换淘宝镜像，再执行<code>hexo init</code></p>
<p><del>当时输完命令就去吃饭了，</del>具体不知道跑了多久</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427191601372.png" alt="image-20240427191601372">		</p>
<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure>

<p>接下来就可以预览博客啦</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>结果如下，访问这段http开头的网址就可以预览了</p>
<p><strong>注意：不要结束命令或者关闭终端！！！所以复制网址的时候别直接ctrl+C</strong></p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427191954231.png" alt="image-20240427191954231"></p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427191939029.png" alt="image-20240427191939029"></p>
<h4 id="4-更换主题"><a href="#4-更换主题" class="headerlink" title="4.更换主题"></a>4.更换主题</h4><p>如果不喜欢默认主题的话，可以更换为next主题（适合新手）</p>
<ul>
<li><p>下载主题</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427192416992.png" alt="image-20240427192416992"></p>
</li>
<li><p>修改配置文件</p>
<p>在自定义的博客文件夹下找到<code>_config.yml</code>文件</p>
<p>将<code>landscape</code>改为<code>next</code></p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427192533655.png" alt="image-20240427192533655"><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427192554514.png" alt="image-20240427192554514"></p>
</li>
<li><p>预览网站</p>
<p>同样的执行<code>hexo s</code></p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427192750576.png" alt="image-20240427192750576"></p>
</li>
</ul>
<h4 id="5-其他配置"><a href="#5-其他配置" class="headerlink" title="5.其他配置"></a>5.其他配置</h4><p>注意区分两个文件，名字都为<code>_config.yml</code></p>
<ol>
<li>站点配置文件：指的是根目录下的，比如<code>D:\blog\_config.yml</code></li>
<li>主题配置文件：指的是具体主题下的，比如<code>D:\blog\themes\next\_config.yml</code></li>
</ol>
<h6 id="a-设置语言"><a href="#a-设置语言" class="headerlink" title="a.设置语言"></a>a.设置语言</h6><p>更改站点配置文件<code>D:\blog\_config.yml</code>，将language改为zh-CN</p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427193621611.png" alt="image-20240427193621611"></p>
<h6 id="b-更改主题外观"><a href="#b-更改主题外观" class="headerlink" title="b.更改主题外观"></a>b.更改主题外观</h6><p>更改主题配置文件<code>D:\blog\themes\next\_config.yml</code></p>
<p>根据需求更改</p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427193801777.png" alt="image-20240427193801777"></p>
<p>你也可以查看文档修改其他值<a target="_blank" rel="noopener" href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a></p>
<p>再执行<code>hexo s</code>预览网站，现在网站长这样啦！</p>
<blockquote>
<p>如果没有更新的话，可以关掉刚刚git bash的窗口，重新打开就可以看到刷新了</p>
</blockquote>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427194518821.png" alt="image-20240427194518821"></p>
<h4 id="6-生成文章的编辑工具"><a href="#6-生成文章的编辑工具" class="headerlink" title="6.生成文章的编辑工具"></a>6.生成文章的编辑工具</h4><p>比如，你想创建一个名为“如何使用github搭建个人博客”的文章</p>
<p>在博客根目录下执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;How to build a personal blog on GitHub&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427195036268.png" alt="image-20240427195036268"></p>
<p>就会生成对应的markdown文件啦</p>
<p>打开文件如下，在这里你可以修改文章标题，在下面输入文章内容</p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427195223632.png" alt="image-20240427195223632"></p>
<p>同样的，执行<code>hexo s</code>预览网站</p>
<h4 id="7-将博客部署到网站上"><a href="#7-将博客部署到网站上" class="headerlink" title="7.将博客部署到网站上"></a>7.将博客部署到网站上</h4><p>现在只是本地预览，将博客部署到网站上，就可以通过域名访问了</p>
<p>可以通过github部署，也可以通过coding部署</p>
<p>我用的是github</p>
<ul>
<li><p>创建一个仓库 Create repository</p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427200514974.png" alt="image-20240427200514974"></p>
</li>
<li><p>仓库名为用户名+.github.io，勾选初始化README</p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427200739418.png" alt="image-20240427200739418"></p>
</li>
</ul>
<blockquote>
<p>进行其他配置，创建一个git密钥</p>
</blockquote>
<ul>
<li>打开git bash，执行（更换为你的邮箱），一直回车</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “your_email@youremail.com“</span><br></pre></td></tr></table></figure>

<p>​	然后执行<code>cat ~/.ssh/id_rsa.pub</code>，复制输出信息</p>
<ul>
<li><p>回到github，点击头像，打开Settings，打开SSH and GPG keys，点击new SSH key</p>
<p>在Key那里粘贴密钥，点击Add SSH Key</p>
</li>
<li><p>打开git bash，执行：<code>ssh -T git@github.com</code>，输入yes回车</p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427201542974.png" alt="image-20240427201542974"></p>
</li>
<li><p>打开项目，点击Code—SSH，复制地址<img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427201722320.png" alt="image-20240427201722320"></p>
</li>
<li><p>打开站点配置文件</p>
<p>修改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yhcslin/yhcslin.github.io.git //更换为你的地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427202617046.png" alt="image-20240427202617046"></p>
</li>
<li><p>在博客根目录下打开git bash，分别执行下面的命令，更换为你的名字和邮箱</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>

<p>安装上传插件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后执行下面的命令上传</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后打开项目，点击Settings—Pages</p>
<p>出现的就是你的网址</p>
<p><img src="/../assets/How-to-build-a-personal-blog-on-GitHub/image-20240427202655378.png" alt="image-20240427202655378"></p>
<h3 id="完结撒花！！！"><a href="#完结撒花！！！" class="headerlink" title="完结撒花！！！"></a>完结撒花！！！</h3></li>
</ul>
<blockquote>
<p>参考链接</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huanhao/p/hexobase.html">https://www.cnblogs.com/huanhao/p/hexobase.html</a> 比我讲的要详细，但是有些在淘宝镜像那里的链接要更新</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2395526">https://cloud.tencent.com/developer/article/2395526</a> 上传图片有问题的可以看这里</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yhcs</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhcs</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
